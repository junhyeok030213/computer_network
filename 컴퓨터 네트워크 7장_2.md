># 7-4 인터넷 프로토콜 버전 4
## 인터넷의 네트워크 계층은 여러 버전을 거쳤지만 IP 버전 4(IPv4)와 IP 버전 6(IPv6)의 두 가지 버전만 살아 남았다.
## IPv4는 거의 고갈되었지만 아직 이 버전을 사용하는 영역이 있고 IPv6의 기반이기 때문에 이에 대해 논의한다.

># 7.4.1 IPv4 주소 지정
## 각 장치의 인터넷 연결을 식별하기 위해 TCP/IP 프로토콜 제품군의 IP 계층에서 사용되는 식별자를 인터넷 주소 또는 IP 주소라고 한다.
## IPv4 주소는 호스트나 라우터의 인터넷 연결을 고유하고 보편적으로 정의하는 32비트 주소이다.
## IP 주소는 호스트나 라우터가 아닌 연결 주소이다.
## ICANN(Internet Corporation for Assigned Names and Numbers)이 IP 주소를 관리하고 있다.

># 주소 공간(Adress Space)
## 주소 공간은 프로토콜이 사용하는 주소의 총 개수이다.
## 프로토콜이 주소를 정의하기 위해 b 비트를 사용하는 경우 각 비트가 두 가지 다른 값(0 또는 1)을 가질 수 있으므로 주소 공간은 2^b이다.
## IPv4는 32비트 주소를 사용한다. 즉, 주소 공간은 2^32 또는 4,294,967,296(40억 이상)이다.
## 제한이 없다면 40억 개 이상의 장치가 인터넷에 연결될 수 있다.

># 표기법
## IPv4 주소를 표시하기 위한 일반적인 표기법은 이진 표기법(베이스 2), 점선 10진 표기법(베이스 256), 16진 표기법(베이스 16) 세 가지가 있습니다.

># 그림 7.4 IPv4 주소 지정에서 세 가지 다른 표기법
<img width="848" alt="스크린샷 2024-04-15 오후 11 39 50" src="https://github.com/junhyeok030213/computer_network/assets/106813806/85b7aa57-d3db-44f8-b6d8-7e8b446f602e">

># 주소 지정의 계층 구조
## 전화 네트워크나 우편 네트워크와 같이 배달과 관련된 모든 통신 네트워크에서 주소 지정 시스템은 계층적이다.
## 32비트 IPv4 주소도 계층적이지만 두 부분으로만 나누어 진다.
## 접두사라고 하는 주소의 첫 번째 부분은 네트워크를 정의한다. 접미사라고 하는 주소의 두번째 부분은 노드를 정의한다.

># 그림 7.5 주소 지정의 계층 구조
<img width="828" alt="스크린샷 2024-04-15 오후 11 53 26" src="https://github.com/junhyeok030213/computer_network/assets/106813806/6dba722a-f56c-421a-9412-4a79fb83d122">

># Classful Addressing(품격있는? 주소지정)
## 인터넷이 시작될 때 IPv4 주소는 고정 길이 접두사로 설계되었으나 크고 작은 네트워크를 모두 수용하기 위해 하나가 아닌 3개의 고정 길이 접두사(n=8, n=16, n=24)로 설계되었다.
## 전체 주소 공간은 그림 7.6과 같이 5개의 클래스(클래스 A, B, C, D, E)로 구분된다.
## 이 체계를 클래스형 주소 지정이라고 한다.
## 클래스형 주소 지정은 과거의 일이지만 나중에 설명할 클래스 없는 주소지정을 이해하는데 도움이 된다.

># 그림 7.6 클래스 주소 지정에서 주소 공간의 점유
<img width="846" alt="스크린샷 2024-04-15 오후 11 58 08" src="https://github.com/junhyeok030213/computer_network/assets/106813806/71683e21-f6ca-407d-921f-680fcccfa272">

># 클래스 없는 주소 지정
## 인터넷이 성장함에 따라 장기적인 솔루션으로 더 큰 주소 공간이 필요하다는 것이 분명해졌다.
## 그러나 주소 공간이 커지면 IP 주소의 길이도 길어져야 하며, 이는 IP 패킷의 형식을 변경해야 함을 의미한다.
## 장기적인 솔루션이 이미 고안되어 IPv6라고 불리지만, 동일한 주소 공간을 사용하되 주소 분포를 변경하여 각 조직에 공정한 공유를 제공하는 단기 솔루션도 고안되었다.
## 단기 솔루션은 여전히 IPv4 주소를 사용하지만 이를 클래스 없는 주소 지정이라고 한다.

># 그림 7.7 클래스 없는 주소 지정에서 가변 길이 블록
><img width="842" alt="스크린샷 2024-04-16 오전 12 01 40" src="https://github.com/junhyeok030213/computer_network/assets/106813806/8dcf68a4-bb4b-4737-a947-79bffcf4f98a">

># 그림 7.8 슬래시 표기법(CIDR)
## CIDR: Classless InterDomain Routing -> 사이더로 발음 (cider)]
<img width="849" alt="스크린샷 2024-04-16 오전 12 02 29" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a4d6954b-7b8f-46fa-b4b5-02ea553d00f8">

># 클래스리스 어드레싱에서 정보 추출
<img width="830" alt="스크린샷 2024-04-16 오전 12 03 03" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b950c47b-a936-43a8-8c67-21a7e3e4356b">

># 예제 7.1
## 클래스 없는 주소는 167.199.170.82/27로 지정된다. 위에 세가지 정보는 다음과 같이 확인할 수 있다. 네트워크의 주소 수는 2^32-n = 25 = 32개 주소이다. 첫 번째 주소는 처음 27비트를 유지하고 나머지는 비트를 0s로 변경하여 찾을 수 있다.

<img width="815" alt="스크린샷 2024-04-16 오전 12 05 24" src="https://github.com/junhyeok030213/computer_network/assets/106813806/7b2f65bf-dc02-4a23-b86a-b1e8e29d2b11">

## 마지막 주소는 처음 27비트를 유지하고 나머지 비트를 1로 변경하면 찾을 수 있다.
<img width="804" alt="스크린샷 2024-04-16 오전 12 05 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/fa07f196-3cfb-4f0a-a542-27920f55ed7d">

># 예제 7.2
## 마스크를 사용하여 예제 7.1을 반복한다. 점으로 구분된 십진수 표기법의 마스크는 256.256.256.224이다. AND, OR 및 NOT 연산은 도서 웹사이트의 계산기와 애플릿을 사용하여 개별 바이트에 적용할 수 있다.
<img width="837" alt="스크린샷 2024-04-16 오전 12 07 11" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b8b7adb6-c910-4ef7-9ef2-c877bdc04625">

># 예제 7.3
## 클래스 없는 주소 지정에서는 주소 자체가 해당 주소가 속한 블럭을 정의할 수 없다. 예를 들어 주소 230.8.24.56은 여러 블럭에 속할 수 있다. 그 중 일부는 해당 블럭과 관련된 접두사 값과 함께 아래에 표기된다.
<img width="787" alt="스크린샷 2024-04-16 오전 12 08 22" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a55f8a78-91bb-405a-b3cf-b2f5b753cc3d">

># 그림 7.9 네트워크 주소
## 네트워크 주소: 블록의 첫 번째 주소는 일반적으로 어떤 장치에도 할당되지 않습니다. 이 주소는 조직을 나머지 세계로 나타내는 네트워크 주소로 사용됩니다.
<img width="836" alt="스크린샷 2024-04-16 오전 12 09 05" src="https://github.com/junhyeok030213/computer_network/assets/106813806/6b48e484-a240-4fe5-93ea-8615ccc6ed87">

># 예제 7.4

## ISP가 1000개의 주소 블럭을 요청하였다. 1000은 2의 거듭제곱이 아니므로 1024개의 주소가 부여된다. 접두사 길이는 n = 32 - log_2 1024 = 22로 계산된다. 사용 가능한 블럭 18.14.12.0/22가 ISP에 부여된다. 10진수의 첫 번째 주소는 302,910,464로 1024로 나누어지는 것을 알 수 있다.

># 7.4.1 IPv4 주소지정: 서브네팅(Subnetting)
## 서브네팅을 사용하여 더 많은 계층을 만들 수 있다. 일정 범위의 주소를 가진 기관(혹은 ISP)은 범위를 부 범위로 나누고, 이를 서브네트워크(혹은 서브넷)에 할당할 수 있다.
## 서브넷 설계
- 기관에 할당된 전체 주소의 수를 N, 접두사의 길이를 n, 각 서브넷에 할당된 주소의 수를 N_sub, 각 서브넷의 접두사의 길이를 n_sub로 가정하자.
- 각 서브네트워크의 주소의 수는 2의 제곱승(power of 2) 이여야 한다.
- 각 서브네트워크의 접두사의 길이는 다음 공식을 이용해 구할 수 있다.
<img width="234" alt="스크린샷 2024-04-16 오전 12 15 02" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c146ff7c-8a32-4376-a3c1-9c131cc8f186">

- 각 서브네트워크의 첫 주소는 서브네트워크의 주소 수로 나눌 수 있어야 한다. 이는 더 큰 서브네트워크에 주소를 먼저 할당하면 된다.

># 예 7.5 - 1
## 조직에는 시작 주소가 14.24.74.0/24인 주소 블럭이 부여된다. 조직은 3개의 서브넷에서 사용할 3개의 주소 하위 블럭(10개 주소의 하위 블럭 1개, 60개 주소의 하위 블럭 1개, 120개 주소의 하위 블럭 1개)이 필요하다. 하위블럭을 디자인해라
# 해결책
## 이 블럭에는 2^(32-24) = 256 개의 주소가 있다. 첫 번째 주소는 14.24.74.0/24이다. 마지막 주소는 14.24.74.255/24이다. 세 번째 요구 사항을 충족하기 위해 가장 큰 것부터 시작하여 가장 작은 것까지 끝나는 하위 블럭에 주소를 할당한다.

># 예 7.5 - 2
## a. 120개의 주소가 필요한 가장 큰 하위 블럭의 주소 수는 2의 거듭제곱이 아니다. 우리는 128개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 n_1 = 32 - log_2 128 =  25로 찾을 수 있다. 이 블럭의 첫 번째 주소는 14.24.74.0/25 이다. 마지막 주소는 14.24.74.127/25이다.
## b. 60개의 주소가 필요한 두 번째로 큰 하위 블럭의 주소 수 역시 2의 거듭제곱이 아니다. 우리는 64개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 n_2= 32 - log_2 64 = 26으로 찾을 있다. 이 블럭의 첫 번째 주소는 14.24.74.128/26이다. 마지막 주소는 14.24.74.191./26이다.

># 예 7.5 - 3
## c. 10개의 주소가 필요한 가장 작은 하위 블럭의 주소 수는 2의 거듭제곱이 아니다. 우리는 16개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 다음과 같이 찾을 수 있다. 이 블럭의 첫 번째 주소는 14.24.74.207/28이다.

## 이전 서브 블럭의 주소를 모두 더하면 208개의 주소가 되며, 이는 48개의 주소가 예비로 남음을 의미한다. 이 범위의 첫 번째 주소는 14.24.74.208이다. 마지막 주소는 14.24.74.255이다. 우리는 아직 접두사 길이의 대해 모른다. 그림 4.36은 블럭 구성을 보여준다. 각 블럭의 첫 번째 주소를 표시하였다.

># 그림 7.10 예제 4.5에 대한 솔루션
<img width="824" alt="스크린샷 2024-04-16 오후 1 15 03" src="https://github.com/junhyeok030213/computer_network/assets/106813806/038ae31b-4e09-4597-a0d5-03cc013cd9b8">

># 예 7.6
## 그림 7.11은 ISP에 의해 4개의 작은 주소 블록이 4개의 조직에 할당되는 방식을 보여줍니다. ISP는 이 4개의 블록을 하나의 블록으로 묶어서 더 큰 블록을 전 세계에 광고합니다. 이 더 큰 블록으로 향하는 패킷은 모두 이 ISP로 보내져야 합니다. 패킷을 적절한 조직에 전달하는 것은 ISP의 책임입니다. 이는 우리가 우편망에서 찾을 수 있는 라우팅과 유사합니다. 한 국가 밖에서 오는 모든 패키지는 먼저 수도로 전송된 다음 해당 목적지로 배포됩니다.

># 그림 7.11 주소 집계의 예
<img width="843" alt="스크린샷 2024-04-16 오후 1 16 37" src="https://github.com/junhyeok030213/computer_network/assets/106813806/420ed461-62b5-419f-bcd1-300eb7f613e2">

># DHCP(Dynamic Host Configuration Protocol - 동적 호스트 구성 프로토콜)
## 주소 블럭이 조직에 할당된 후 네트워크 관리는 개별 호스트 또는 라우터에 주소를 수동으로 할당할 수 있다.
## 그러나 조직 내 주소 할당은 DHCP(동적 호스트 구성 프로토콜)를 사용하여 자동으롤 수행될 수 있다.
## DHCP는 클라이언트-서버 패러다임을 사용하는 응용 프로그램 계층 프로그램으로 네트워크 계층에서 실제로 TCP/IP를 지원한다.

># DHCP 메시지 형식
<img width="372" alt="스크린샷 2024-04-16 오후 1 20 48" src="https://github.com/junhyeok030213/computer_network/assets/106813806/0fa18c78-ea9a-4a22-bbe2-d6a44d3621e9">

## Fields:
- Opcode: 작업 코드, 요청(1) 또는 요청(2)
- Htype: 하드웨어 유형(이더넷, ...)
- HLen: 하드웨어 주소의 길이
- HCount: 패킷이 이동할 수 있는 최대 홉 수
- Transaction ID: 클라이언트가 설정하고 서버가 반복하는 정수
- Time elaped(경과 시간): 클라이언트가 부팅을 시작한 이후 경과한 시간(초)
- Flags(플래그): 첫 번째 비트는 유니캐스트(0) 또는 멀티캐스트(1)를 정의한다. 다른 15비트는 사용되지 않는다.
- 클라이언트 IP 주소: 클라이언트가 이를 모르는 경우 0으로 설정
- Your IP 주소: 서버가 보낸 클라이언트 IP 주소
- 게이트웨이 IP 주소: 기본 라우터의 주소
- 서버 이름: 서버의 64바이트 도메인 이름
- 부팅 파일 이름: 추가 정보가 포함된 128바이트 파일 이름
- 옵션: 텍스트로 설명된 이중 목적을 가진 64바이트 필드

># 옵션 형식
<img width="625" alt="스크린샷 2024-04-16 오후 1 29 44" src="https://github.com/junhyeok030213/computer_network/assets/106813806/614aee52-6b49-4525-802e-dc5825ba2829">

># DHCP 옵션
<img width="734" alt="스크린샷 2024-04-16 오후 1 30 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c9aaa980-f97f-48d9-a3a4-ed01a1f831ac">

># 18.4.5 NAT
<img width="769" alt="스크린샷 2024-04-16 오후 1 34 27" src="https://github.com/junhyeok030213/computer_network/assets/106813806/eacabbae-1990-43b8-88f9-491d4eb9f7dd">

## 대부분의 경우 소규모 네트워크에 있는 컴퓨터 중 일부만 동시에 인터넷 액세스해야 함
## 개인 주소와 범용 주소 간의 매핑을 제공하는 동시에 가상 사설망을 지원할 수 있는 기술이 NAT(Network Address Translation)이다.
## 이 기술을 통해 사이트는 내부 통신을 위해 일련의 개인 주소를 사용하고 나머지 세계와의 통신을 위해 일련의 글로벌 인터넷 주소(최소 하나)를 사용할 수 있다.

># 주소번역
<img width="841" alt="스크린샷 2024-04-16 오후 1 34 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/39a5c9a9-42fb-4917-b6b2-d5d8337c5b3c">

># Translation
<img width="843" alt="스크린샷 2024-04-16 오후 1 36 45" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d9b08dc6-9155-4b9b-bd42-92cca53c6bd6">

># Five-column translation table(오열통역표)
<img width="809" alt="스크린샷 2024-04-16 오후 1 37 24" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b41e7749-5e08-4e07-be02-a95525de485f">

># 7.4.2 4가지 관련 프로토콜(Main and Auxiliary(보조의) Protocols)
## IPv4 프로토콜
- Packetizing(패킷화)
- Forwarding(포워딩)
- Delivery of a packet(패킷 전달)
## ICMPv4(Internet Control Message Protocol Version 4)
- IPv4를 도와 네트워크층의 전송 중 발생할 수 있는 오류를 제어함
## IGMP(Internet Group Management Protocol)
- IPv4의 멀티캐스트를 도와줌
## ARP(Address Resolution Protocol)
- 네트워크층 주소와 링크 계층 주소를 매핑

># 그림 7.12 TCP/IP 프로토콜 스위트에서 IP 및 기타 네트워크 계층 프로토콜의 위치
<img width="835" alt="스크린샷 2024-04-16 오후 1 45 51" src="https://github.com/junhyeok030213/computer_network/assets/106813806/792f3781-18fe-4a0b-8e12-2111bd98d984">

># IPv4의 특성
## 신뢰할 수 없고 연결되지 않음
## 최선의 배송 서비스: 오류 제어 또는 흐름 제어 없음(헤더 오류 및 감지 제외)
## 최고의 전송이지만 보장할 수는 없다.
## 안정적인 전송이 필요한 경우 IPv6는 TCP와 긴밀하게 작동한다.
## IPv4 계층의 패킷을 데이터그램이라고 한다.

># 데이터그램 형식
## IP가 사용하는 패킷을 데이터그램이라고 한다.
## 그림 7.13은 IPv4 데이터그램 형식을 보여준다.
## 데이터그램은 헤더와 페이로드(데이터) 두 부분으로 구성된 가변길이 패킷이다.
## 헤더의 길이는 20~60바이트이며 라우팅 및 전달에 필수적인 정보를 포함한다.
## TCP/IP에서는 헤더를 4바이트 섹션으로 표시하는 것이 관례이다.

># 그림 7.13 IP 데이터그램
<img width="734" alt="스크린샷 2024-04-16 오후 1 51 34" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d154ebfe-82f8-4a42-adc6-055b377f2a15">

># IPv4 데이터그램 형식
## 버전(VER): 사용된 프로토콜 버전을 나타낸다.
## 헤더 길이(HLEN): 총 길이(4바이트 워드), 헤더 길이는 20~60바이트 사이에서 가변적입니다. 예를 들어, 20바이트의 경우 HLEN 5의 값이다.
## 서비스: IETF는 서비스 유형에서 차별화된 서비스로 이름을 변경하였다.
<img width="653" alt="스크린샷 2024-04-16 오후 2 03 12" src="https://github.com/junhyeok030213/computer_network/assets/106813806/eaa4d689-a040-42ea-b4d8-c5030e624645">

## 식별: 조각화에 사용된다.
- 시퀀스 번호
- 데이터그램을 고유하게 식별하기 위해 주소 및 사용자 프로토콜과 함께 사용된다.(IP 주소 + 시퀀스 번호)
## 플래그: 조각화에 사용된다.
## 조각화 오프셋: 조각화에 사용된다.
## 생존 시간: 인터넷을 통한 여행의 제한된 수명
- 홉 수(보통 소스와 대상 간 최대 라우터 수의 2배)
- 데이터그램이 라우터를 방문할 때마다 1씩 감소

># 7.4.2 데이터그램 형식: 헤더 필드(3)
## 헤더 검사합(Header checksum): 16 bits
- 각 라우터에서 확인 및 재계산
- 16비트 1은 헤더의 모든 16비트 워드의 합을 보완합니다
- 계산 중에 0으로 설정

## 발신지 주소(Source address): 32 bits
## 목적지 주소(Destination address): 32 bits
## 선택사항(Options): 네트워크 테스트/디버깅에 사용됨
## 패딩(Padding): 길이 32비트의 배수로 채우기
## 페이로드(Payload):
- 상위 계층의 사용자 데이터 전달
- 8 비트 길이(octet)의 정수 배
- 데이터그램의 최대 길이(헤더 + 데이터)는 65.535 octets

># 그림 7.14 프로토콜 필드 값을 이용한 다중화 및 역다중화
<img width="849" alt="스크린샷 2024-04-16 오후 2 13 52" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b5ccd17d-4dc3-4c1f-8ec3-d5fc3f69d94d">

># 예 7.7
## 처음 8비트가 (01000010)_2인 IPv4 패킷이 도착했다. 수신자는 패킷을 왜 폐기하는가?
# 해결책
## 이 패킷에 오류가 있다. 가장 왼쪽의 4비트(0010)_2는 올바른 버전을 표시한다. 다음 4비트(0010)_2는 잘못된 헤더길이(2*4=8)를 나타낸다. 헤더의 최소 바이트 수는 20이어야 한다. 패킷이 전송중에 손상되었다.

># 예 7.8
## IPv4 패킷에서 HLEN 값은 (1000)_2 이다. 이 패킷에는 몇 바이트 옵션이 전달되나?
# 해결책
## HLEN 값은 8이다. 이는 헤더의 총 바이트 수가 8*4, 즉 32바이트임을 의미한다. 처음 20바이트는 기본 헤더이고 다음 12바이트는 옵션이다.

># 예 7.9
## IPv4 패킷에서 HLEN의 값은 5이고, 전체 길이 필드의 값은 (0028)_16이다. 이 패킷에는 몇 바이트의 데이터가 전달 되는가?
# 해결책
## HLEN 값은 5다. 이는 헤더의 총 바이트 수가 5*4, 즉 20바이트(옵션 없음)임을 의미한다. 총 길이는 (0028)_16 또는 40바이트이다. 이는 패킷이 20바이트의 데이터(40-20)를 전달한다는 의미이다.

># 예 7.10
## 표시된 것처럼 처음 몇개의 16진수 숫자가 포함된 IPv4 패킷이 도착했다.
<img width="343" alt="스크린샷 2024-04-16 오후 4 13 26" src="https://github.com/junhyeok030213/computer_network/assets/106813806/bbe23877-cc69-4400-80fe-f8338c07be40">

## 이 패킷이 삭제되기 전에 몇 홉을 이동할 수 있는가? 데이터는 어떤 상위 계층 프로토콜에 속하는가?
# 해결책
## TTL(Time-To-Live)필드를 찾으려면 8바이트(16자리 16진수)를 건너뛴다. TTL(Time-To-Live) 필드는 9번째 바이트(01)_16이다. 이는 패킷이 한 홉만 이동할 수 있음을 의미한다. 프로토콜 필드는 다음 바이트(02)_16이며, 이는 상위 계층 프로토콜이 IGMP임을 의미한다.

># 예 7.11
## 그림 7.15는 옵션이 없는 IPv4 헤더에 대한 체크섬 계산 예를 보여줍니다. 헤더는 16비트 섹션으로 나뉩니다. 모든 섹션이 추가되고 가장 왼쪽 자리를 감싼 후 합산이 보완됩니다. 결과는 체크섬 필드에 삽입됩니다.

># 그림 7.15 체크섬 계산 예시
<img width="640" alt="스크린샷 2024-04-16 오후 4 17 50" src="https://github.com/junhyeok030213/computer_network/assets/106813806/f2319de7-c38b-4987-a4c6-bf047909bac0">

># Fragmentation(분열, 파쇄)
## 데이터그램은 다양한 네트워크를 통해 이동할 수 있습니다. 
## 각 라우터는 수신한 프레임에서 IP 데이터그램을 캡슐화 해제하고 처리한 다음 다른 프레임에 캡슐화합니다.
## 수신된 프레임의 형식과 크기는 프레임이 방금 이동한 물리적 네트워크에서 사용하는 프로토콜에 따라 달라집니다. 
## 전송된 프레임의 형식과 크기는 프레임이 이동할 물리적 네트워크에서 사용하는 프로토콜에 따라 달라집니다. 
## 예를 들어 라우터가 LAN을 WAN에 연결하면 LAN 형식의 프레임을 수신하고 WAN 형식의 프레임을 전송합니다.

># 최대 전송 단위
## 각 링크 계층 프로토콜에는 고유한 프레임 형식이 있습니다. 
## 각 형식의 특징 중 하나는 프레임에 캡슐화할 수 있는 페이로드의 최대 크기이며, 데이터그램의 전체 크기는 최대 크기보다 작아야 합니다(그림 7.16 참조).

># 그림 7.16 Maximum transfer unit (MTU) - 최대 전달 단위
<img width="842" alt="스크린샷 2024-04-16 오후 4 20 30" src="https://github.com/junhyeok030213/computer_network/assets/106813806/e5f5587c-59ab-417f-a5cf-fc5a080f7acf">

># 일부 네트워크의 MTU
<img width="551" alt="스크린샷 2024-04-16 오후 4 20 55" src="https://github.com/junhyeok030213/computer_network/assets/106813806/810ef01f-9f9e-4964-b8ee-b96353de9121">

># 분열
## 단편화 관련 분야
- 식별: 16비트
 
  -> 소스 호스트는 식별 및 IPv4 주소를 고유하게 정의한다.

  -> 카운터는 1을 증가시켜 각 데이터그램의 고유성을 부여하는데 사용된다.

  -> 데이터그램이 단편화되면 목적지의 재조립을 돕기 위해 각 단편은 동일한 식별 번호를 갖습니다.

- 플래그: 3비트

  -> 첫 번째 비트: 예약됨

  -> 두 번째 비트: 기계가 데이터그램을 조각내지 않아야 함을 나타내는 비트를 조각내지 마십시오. 어떤 물리적 네트워크도 데이터그램을 전달할 수 없기 때문에 소스 호스트에 ICMP 오류 메시지를 발행합니다

  -> 세 번째 비트: 이 비트 이후에 더 많은 조각이 있음을 나타내는 추가 조각 비트이다.
  
  <img width="525" alt="스크린샷 2024-04-16 오후 4 27 48" src="https://github.com/junhyeok030213/computer_network/assets/106813806/0ddbbd1d-65e5-43d4-b0ce-df7aa80ee59b">

- 조각화 오프셋: 13비트

  -> 전체 데이터그램에 대한 이 조각의 상대적 위치를 표시한다.

  -> 데이터의 오프셋은 8바이트 단위이다.

<img width="661" alt="스크린샷 2024-04-16 오후 4 31 58" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d7053996-6471-4c4e-aae7-f8f0a56d0cc5">

># 그림 7.18 상세 파편화 예시
<img width="610" alt="스크린샷 2024-04-16 오후 4 32 26" src="https://github.com/junhyeok030213/computer_network/assets/106813806/4a9ab61d-b331-4516-ac64-55cb1a27e776">

># 예 7.12
## M 비트 값이 0인 패킷이 도착했습니다. 이것은 첫 번째 조각인가요, 마지막 조각인가요, 아니면 중간 조각인가요? 패킷이 조각난 것인지 알 수 있나요?
# 해결책
## M 비트가 0이면 프래그먼트가 더 이상 없음을 의미하며 프래그먼트가 마지막 프래그먼트입니다. 그러나 원래 패킷이 프래그먼트화되었는지 여부는 말할 수 없습니다. 프래그먼트화되지 않은 패킷이 마지막 프래그먼트로 간주됩니다.

># 예 7.13
## M 비트 값이 1인 패킷이 도착했습니다. 이것은 첫 번째 조각인가요, 마지막 조각인가요, 아니면 중간 조각인가요? 패킷이 조각난 것인지 알 수 있나요?
# 해결책
## M비트가 1이면 프래그먼트가 하나 이상 더 있다는 뜻입니다. 이 프래그먼트는 처음 프래그먼트가 될 수도 있고 중간 프래그먼트가 될 수도 있지만 마지막 프래그먼트가 될 수도 없습니다. 첫 번째 프래그먼트인지 중간 프래그먼트 오프셋 값이 더 필요합니다.

># 예 7.14
## M 비트 값이 1이고 조각화 오프셋 값이 0인 패킷이 도착했습니다. 첫 번째 조각인가요, 마지막 조각인가요, 중간 조각인가요?
# 해결책
## M 비트는 1이므로 첫 번째 조각이거나 중간 조각입니다. 오프셋 값이 0이므로 첫 번째 조각입니다.

># 예 7.15
## 오프셋 값이 100인 패킷이 도착했습니다. 첫 번째 바이트의 개수는 무엇입니까? 우리는 마지막 바이트의 개수를 알고 있습니까?
# 해결책
## 첫 번째 바이트의 수를 구하기 위해서 우리는 오프셋 값에 8을 곱합니다. 이것은 첫 번째 바이트의 수가 800이라는 것을 의미합니다. 우리는 데이터의 길이를 알지 못하면 마지막 바이트의 수를 결정할 수 없습니다.

># 예 7.16
## 오프셋 값이 100, HLEN 값이 5, 전장 필드 값이 100인 패킷이 도착했습니다. 첫 번째 바이트와 마지막 바이트의 개수는 무엇입니까?
# 해결책
## 첫 번째 바이트 번호는 100 * 8 = 800입니다. 총 길이는 100 바이트이고 헤더 길이는 20 바이트 (5 * 4)이므로 이 데이터그램에는 80 바이트가 있습니다. 첫 번째 바이트 번호가 800이면 마지막 바이트 번호는 879여야 합니다.

># 7.4.3 옵션
## IPv4 데이터그램의 헤더는 고정 부분과 가변 부분의 두 부분으로 구성됩니다. 
## 고정 부품의 길이는 20바이트이며 이전 섹션에서 논의했습니다. 
## 변수 부분은 헤더의 경계를 보존하기 위해 최대 40바이트(4바이트의 배수)가 될 수 있는 옵션으로 구성됩니다.

># Options
## 최대 40바이트
## 네트워크 테스트 및 디버깅에 사용된다.
## 무작동 옵션: 1바이트, 옵션 간 채우기로 사용
## 옵션 끝 옵션: 1바이트, 패딩에 사용되며 마지막 옵션으로만 사용됨
## 라우팅 기록 옵션: 인터넷 라우터를 기록하고 최대 9개의 라우터 주소를 나열하며 디버깅 및 관리에 사용된다.
## 엄격한 소스 경로 옵션: 데이터그램의 경로를 미리 결정하기 위해 소스에서 사용된다.
- 특정 유형의 서비스가 포함된 경로
- 발신자의 목적에 맞게 더욱 안전하거나 신뢰할 수 있음
## 느슨한 소스 경로 옵션: 엄격한 소스 경로와 유사하지만 덜 엄격하므로 데이터그램이 다른 라우터도 방문할 수 있다.
## 타임스탬프 옵션: 자정부터 밀리초 단위로 표시되는 라우터의 데이터그램 처리 시간을 기록하는데 사용된다.

># IPv4의 옵션 분류
<img width="734" alt="스크린샷 2024-04-16 오후 4 48 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/01085b85-00c6-4fa3-86df-653ba13d9743">

># IPv4 데이터그램의 보안
<img width="200" alt="스크린샷 2024-04-16 오후 4 51 52" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b10adb8b-26cd-4683-8020-b92caa44a385">

## 패킷 스니핑
- 패킷을 가로채서 복사한다.
- 수동적 공격(패킷 내용 변경 없음)
- 감지하기 어려움
- 솔루션 -> 패킷 암호화

## 패킷 수정
- 패킷을 가로채서 수정한다.
- 패킷의 내용 변경
- 데이터 무결성 메커니즘을 사용하여 탐지

## IP 스푸핑
- 다른 사람으로 가장하여 IP 패킷 생성
- 예) 고객 중 한 명이 보낸 것처럼 가장하여 은행에 IP 패킷을 보낸다.
- 원본 인증 메커니즘을 사용하여 방지

># IPsec(보안)
## 공격을 보호하는 IP 보안
## 두 엔터키 간의 연결 지향 서비스
- 알고리즘 및 키 정의
- 패킷 암호화
- 데이터 무결성
- 원산지 인증

># 7.4.4 ICMPv4
## IPv4에는 오류 보고 또는 오류 수정 메커니즘이 없습니다. 
## IP 프로토콜에는 호스트 및 관리 쿼리를 위한 메커니즘도 없습니다. 
## ICMPv4(Internet Control Message Protocol version 4)는 위의 두 가지 결함을 보완하기 위해 설계되었습니다.

># 메시지
## ICMP 메시지는 오류 보고 메시지와 쿼리 메시지의 두 가지 넓은 범주로 나뉩니다. 
## 오류 보고 메시지는 라우터 또는 호스트(대상)가 IP 패킷을 처리할 때 발생할 수 있는 문제를 보고합니다. 
## 쌍으로 발생하는 쿼리 메시지는 호스트 또는 네트워크 관리자가 라우터 또는 다른 호스트에서 특정 정보를 가져오는 데 도움이 됩니다.
## 예를 들어, 노드들은 그들의 이웃들을 발견할 수 있습니다. 또한, 호스트들은 그들의 네트워크 상의 라우터들을 발견하고 배울 수 있고, 라우터들은 노드가 그들의 메시지들을 리디렉션하는 것을 도울 수 있습니다.

># 그림 7.19 ICMP 메시지의 일반 형식
<img width="848" alt="스크린샷 2024-04-16 오후 5 10 28" src="https://github.com/junhyeok030213/computer_network/assets/106813806/29d5253a-9724-4eec-afd9-5853d23eac85">

># 그림 7.20 오류 메시지의 데이터 필드 내용
<img width="838" alt="스크린샷 2024-04-16 오후 5 11 42" src="https://github.com/junhyeok030213/computer_network/assets/106813806/78ede3a5-2a20-4b08-816b-86978e8a70eb">

># 오류 보고
## 목적지에 도달할 수 없음
- 라우터가 데이터그램을 라우팅할 수 없거나 호스트가 데이터그램을 전달할 수 없는 경우 데이터그램을 삭제한 후 대상에 도달할 수 없다는 메시지를 스스로 다시 보낸다.
## 소스 퀸치
- 흐름 제어 부족을 해결하기 위해
- 라우터나 호스트가 혼잡으로 인해 데이터그램을 폐기하면 데이터그램 발신자에게 소스 퀀치 메시지를 보낸다.

 -> 데이터그램이 폐기되었음을 소스에 알린다.

 -> 경로 어딘가에 소스 정체가 있음을 경고한다.

## 시간이 초과.
- TTL 값이 0에 도달하면 라우터는 데이터그램을 폐기한 후 시간 초과 메시지를 스스로 보낸다.

## 매개변수 문제
- 라우터나 목적지가 데이터그램의 어떤 필드에서 모호하거나 누락된 값을 발견하면 데이터그램을 버린 후 매개변수 문제 메시지를 소스에 보낸다.
## Redirection(리디렉션)
<img width="827" alt="스크린샷 2024-04-16 오후 5 17 17" src="https://github.com/junhyeok030213/computer_network/assets/106813806/22181bfb-d3e7-4e36-869a-322bd03c431b">

># Query Messages(쿼리(의혹,질문) 메시지)
## 일부 네트워크 문제를 진단할 수 있습니다
<img width="833" alt="스크린샷 2024-04-16 오후 5 21 19" src="https://github.com/junhyeok030213/computer_network/assets/106813806/704441ed-7ac3-4348-a814-deb69e48aae0">

## 에코 요청 및 응답
- 진단 목적으로
- 두 시스템이 IP 수준에서 서로 통신할 수 있는지 여부 결정
- 일련의 에코 요청 및 에코 응답 메시지를 생성하는 Ping 명령
## 타임스탬프 요쳥 및 응답
- 왕복 시간을 결정
## 주소 마스크 요청 및 응답
- 호스트가 자신의 마스크를 모르는 상태에서 IP 주소를 알 수 있음 -> 라우터가 주소-마스크-응답 메시지로 응답함
## 라우터 요청 및 광고
- 라우터가 살아 있고 작동하는지를 물어보아라

># 디버깅 도구
## 인터넷에서 디버깅에 사용할 수 있는 몇 가지 도구가 있습니다. 
## 호스트 또는 라우터의 실행 가능성을 결정할 수 있습니다. 
## 패킷의 경로를 추적할 수 있습니다. 
## ICMP를 디버깅에 사용하는 두 가지 도구, ping과 tracerroute를 소개합니다.

># Ping
## 핑 프로그램을 사용하여 호스트가 살아 있고 응답하고 있는지 확인할 수 있습니다.

># 예 7.17
## 다음은 auniversity.edu 사이트에 ping 메시지를 보내는 방법을 보여줍니다.
<img width="779" alt="스크린샷 2024-04-16 오후 5 58 45" src="https://github.com/junhyeok030213/computer_network/assets/106813806/4d721453-fcae-4952-903c-72c0ccd6d94b">

># Traceroute or Tracert(추적 경로 또는 추적)
## UNIX의 traceroute 프로그램이나 윈도우즈의 tracerert를 사용하여 소스에서 대상으로 패킷의 경로를 추적할 수 있습니다. 
## 경로를 따라 방문하는 모든 라우터의 IP 주소를 찾을 수 있습니다. 
## 프로그램은 보통 최대 30홉(라우터)의 방문 여부를 확인하도록 설정됩니다. 
## 인터넷의 홉 수는 일반적으로 이보다 적습니다.

># 그림 7.21 추적 경로 프로그램의 예
<img width="823" alt="스크린샷 2024-04-16 오후 5 59 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/84a798fd-6b2d-4866-9c23-5b05460a3143">

># ICMP Checksum
## ICMP에서 체크섬은 전체 메시지(헤더 및 데이터)에 대해 계산됩니다.

># 예 7.18
## 그림 7.22는 간단한 에코 요청 메시지에 대한 체크섬 계산 예를 보여줍니다. 우리는 식별자를 1로, 시퀀스 번호를 9로 임의로 선택했습니다. 메시지는 16비트(2바이트) 워드로 나뉩니다. 워드가 추가되고 합산이 보완됩니다. 이제 송신자는 체크섬 필드에 이 값을 넣을 수 있습니다.

># 그림 7.22 체크섬 계산 예시
<img width="737" alt="스크린샷 2024-04-16 오후 6 02 17" src="https://github.com/junhyeok030213/computer_network/assets/106813806/79b664cc-f6e8-4cb0-800e-03f9fe857f6e">

># 7.4.5  Mobile IP
## 이 장의 마지막 부분에서는 모바일 IP에 대해 설명합니다. 
## 노트북과 같은 모바일 및 개인용 컴퓨터가 점차 대중화됨에 따라 모바일 컴퓨터를 연결이 가능한 어느 위치에서나 인터넷에 연결할 수 있는 IP 프로토콜의 확장인 모바일 IP에 대해 생각해 볼 필요가 있습니다. 
## 이 섹션에서는 이 문제에 대해 논의합니다.

># Addressing
## IP 프로토콜을 이용한 이동통신을 제공함에 있어서 해결해야 할 주요 문제는 해결하는 것입니다.
- 집주소 : 원래주소,영구주소
- 주소: 외부 네트워크와 연결된 임시 주소

># 그림 7.23 집 주소 및 관리 주소
<img width="835" alt="스크린샷 2024-04-16 오후 6 04 17" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c28c72fb-6df7-46ae-803a-4c90cb79197b">

># Agents
## 주소 변경을 인터넷의 나머지 부분에 투명하게 하려면 홈 에이전트와 외국 에이전트가 필요합니다. 
## 그림 7.24는 홈 네트워크에 상대적인 홈 에이전트와 외부 네트워크에 상대적인 외부 에이전트의 위치를 나타냅니다.

># 그림 7.24 홈 에이전트 및 외국 에이전트
<img width="833" alt="스크린샷 2024-04-16 오후 6 05 37" src="https://github.com/junhyeok030213/computer_network/assets/106813806/f22dc0b8-c9f6-4b2f-848e-424596c60525">

># Three Phases
## 모바일 호스트는 원격 호스트와 통신하기 위해 그림 7.25와 같이 에이전트 검색, 등록 및 데이터 전송의 세 단계를 거칩니다.

># 그림 7.25 원격 호스트 및 모바일 호스트 통신
<img width="685" alt="스크린샷 2024-04-16 오후 6 07 55" src="https://github.com/junhyeok030213/computer_network/assets/106813806/3f68bd44-02bc-484a-aca3-ff676219e4e8">

># 그림 7.26 에이전트 광고
<img width="818" alt="스크린샷 2024-04-16 오후 6 08 09" src="https://github.com/junhyeok030213/computer_network/assets/106813806/4191aad9-8a43-4518-8370-7df1c314dfd2">

># 표 7.1 코드 비트
<img width="645" alt="스크린샷 2024-04-16 오후 6 08 31" src="https://github.com/junhyeok030213/computer_network/assets/106813806/efcddd9d-837d-4d21-997b-11b49c0540a4">

># Registration(등록)
## 이동통신에서 두 번째 단계는 등록입니다. 모바일 호스트가 외부 네트워크로 이동하여 외부 에이전트를 발견한 후 등록해야 합니다. 등록에는 네 가지 측면이 있습니다:
1. 모바일 호스트는 외부 에이전트에 자신을 등록해야 합니다.
2. 모바일 호스트는 홈 에이전트에 자체 등록해야 합니다.
3. 모바일 호스트가 만료된 경우 등록을 갱신해야 합니다.
4. 모바일 호스트는 반환될 때 등록을 취소해야 합니다.

># 그림 7.27 등록 요청 양식
<img width="820" alt="스크린샷 2024-04-16 오후 6 10 00" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a5d6064c-3600-409b-b437-e720e71f0f05">

># 표 7.2 등록 요청 플래그 필드 비트
<img width="699" alt="스크린샷 2024-04-16 오후 6 10 22" src="https://github.com/junhyeok030213/computer_network/assets/106813806/5665b6c5-3888-4ae7-a1c1-5f593c85aa1e">

># 그림 7.28 등록 회신 양식
<img width="819" alt="스크린샷 2024-04-16 오후 6 10 49" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d9ee4bd9-7379-4e65-85c8-308f82391739">

># 데이터 전송
## 에이전트 검색 및 등록 후 모바일 호스트는 원격 호스트와 통신할 수 있습니다. 그림 7.29는 이러한 아이디어를 보여줍니다.

># 그림 7.29 데이터 전송
<img width="822" alt="스크린샷 2024-04-16 오후 6 12 01" src="https://github.com/junhyeok030213/computer_network/assets/106813806/1afa472a-cff6-4a35-95e2-245727c71a87">

># 그림 7.30 이중 횡단
<img width="814" alt="스크린샷 2024-04-16 오후 6 12 23" src="https://github.com/junhyeok030213/computer_network/assets/106813806/5d7e2fe1-d0d9-43b9-8b8e-ccd3300427a7">

># 그림 7.31 삼각형 라우팅
<img width="829" alt="스크린샷 2024-04-16 오후 6 12 49" src="https://github.com/junhyeok030213/computer_network/assets/106813806/4b956d22-2dd4-462d-82fb-7f743d196df7">

># 7.4.6 IP 패킷의 포워딩
## 우리는 이 장에서 앞서 네트워크 계층에서 포워딩의 개념에 대해 논의했습니다. 
## 이 섹션에서는 포워딩에서 IP 주소의 역할을 포함하도록 개념을 확장합니다.  
## 이전에 논의했듯이 전달은 패킷을 목적지까지의 경로에 배치하는 것을 의미합니다. 
## 오늘날 인터넷은 링크(네트워크)들의 조합으로 이루어져 있기 때문에, 포워딩은 패킷을 다음 홉(최종 목적지 또는 중간 연결 장치가 될 수 있음)으로 전달하는 것을 의미합니다. 
## IP 프로토콜은 원래 무연결 프로토콜로 설계되었지만, 현재는 연결 중심 프로토콜로 변경하는 경향이 있습니다. 두 경우 모두에 대해 논의합니다.

># 대상 주소를 기준으로 한 포워딩
## 먼저 목적지 주소를 기준으로 출고에 대해 논의합니다. 
## 이것은 오늘날 널리 퍼져 있는 전통적인 접근 방식입니다. 
## 이 경우 포워딩을 하려면 호스트 또는 라우터에 포워딩 테이블이 있어야 합니다. 
## 호스트에 전송할 패킷이 있거나 라우터가 전송할 패킷을 수신한 경우 이 테이블을 보고 패킷을 전송할 다음 홉을 찾습니다.

># 그림 7.32 클래스리스 주소의 단순화된 전달 모듈
<img width="833" alt="스크린샷 2024-04-16 오후 6 14 51" src="https://github.com/junhyeok030213/computer_network/assets/106813806/8e3e718f-a7cc-4736-84dd-4acf64653f7d">

># 예 7.19
## 그림 7.33의 구성을 사용하여 라우터 R1의 포워딩 테이블을 만듭니다.

># 그림 7.33 예제 7.19의 구성
<img width="706" alt="스크린샷 2024-04-16 오후 6 15 49" src="https://github.com/junhyeok030213/computer_network/assets/106813806/93dfaccb-9f6a-455c-a3d3-f41694f840b3">

># 표 7.3 라우터 R1의 전달 표
<img width="699" alt="스크린샷 2024-04-16 오후 6 16 13" src="https://github.com/junhyeok030213/computer_network/assets/106813806/4079046c-cb0e-4604-817a-0f061934c509">

># 예제 7.20
## 표 7.3 대신 표 7.4를 사용할 수 있는데, 여기서 네트워크 주소/마스크는 비트 단위로 제공됩니다.

># 표 7.4 접두사 비트를 사용한 라우터 R1의 전달 표
<img width="791" alt="스크린샷 2024-04-16 오후 6 17 12" src="https://github.com/junhyeok030213/computer_network/assets/106813806/09b19bc1-28cc-46fe-83f7-3a8fb81a8ba7">

># 예 7.21
## Q: 180.70.65.140의 목적지 주소를 사용하여 그림 7.33의 R1에 패킷이 도착하는 경우 포워딩 과정을 보여줍니다

## 라우터는 다음 단계를 수행합니다

### 1. 첫 번째 마스크(/26)가 대상 주소에 적용됩니다. 결과는 180.70.65.128로 해당 네트워크 주소와 일치하지 않습니다.
### 2. 두 번째 마스크(/25)는 목적지 주소에 적용됩니다. 그 결과 180.70.65.128로 해당 네트워크 주소와 일치하게 됩니다. 패킷의 포워딩을 위해 넥스트 홉 주소와 인터페이스 번호 m0을 추출합니다.

># 그림 7.34 주소 집계
<img width="729" alt="스크린샷 2024-04-16 오후 6 19 14" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a3a9abcb-42fe-4aa4-91a8-8320ca33dcc8">

># 그림 7.35 가장 긴 마스크 주소 지정
<img width="812" alt="스크린샷 2024-04-16 오후 6 19 35" src="https://github.com/junhyeok030213/computer_network/assets/106813806/0eb7ffa9-f5f5-4bdc-966b-10d994b181f5">

># 예 7.22
## 계층적 라우팅의 예로, 을 고려해 보겠습니다. 지역 ISP는 120.14.64.0부터 16,384개의 주소를 부여받습니다. 지역 ISP는 이 블록을 각각 4096개의 주소를 가진 4개의 서브블록으로 나누기로 결정했습니다. 이 서브블록들 중 3개는 3개의 지역 ISP에 할당되고, 두 번째 서브블록은 향후 사용을 위해 예약됩니다. 마스크 /18이 있는 원래 블록은 4개의 블록으로 분할되기 때문에 각 블록에 대한 마스크는 /20입니다.

># 그림 7.36 ISP를 사용한 계층적 라우팅
<img width="846" alt="스크린샷 2024-04-16 오후 6 20 43" src="https://github.com/junhyeok030213/computer_network/assets/106813806/26b098e3-5dbc-4715-86ae-f15cf0daa593">

># 포워딩 테이블 검색 알고리즘
## 클래스리스 주소 지정에서는 대상 주소에 네트워크 정보가 없습니다. 
## 가장 간단하지만 가장 효율적이지 않은 검색 방법을 (앞에서 설명했듯이) 가장 긴 접두사 일치라고 합니다. 
## 포워딩 테이블은 각 접두사마다 하나씩 버킷으로 나눌 수 있습니다. 
## 라우터는 먼저 가장 긴 접두사를 시도합니다. 
## 이 버킷에서 대상 주소를 찾으면 검색이 완료됩니다. 
## 주소를 찾을 수 없으면 다음 접두사 등이 검색됩니다. 이런 유형의 검색은 시간이 오래 걸리는 것이 분명합니다.

># 레이블 기반 전달
## 1980년대에 IP를 어떻게든 바꾸려는 노력은 라우팅이 스위칭으로 대체되는 연결 지향 프로토콜처럼 작동하기 시작했습니다. 
## 앞서 논의한 바와 같이, 연결 지향 네트워크(가상 회로 접근 방식)에서, 스위치는 패킷에 부착된 라벨을 기반으로 패킷을 포워딩합니다. 
## 라우팅은 일반적으로 테이블의 내용을 검색하는 것을 기반으로 하며, 전환은 인덱스를 사용하여 테이블에 액세스함으로써 수행될 수 있습니다. 즉, 라우팅은 검색을 포함하고, 전환은 액세스를 포함합니다.

># 예 7.23
## 그림 7.37은 가장 긴 마스크 알고리즘을 사용하여 포워딩 테이블에서 검색하는 간단한 예를 보여줍니다. 오늘날 더 효율적인 알고리즘이 몇 가지 있지만 원리는 동일합니다.

># 그림 7.37 예 7.23
<img width="771" alt="스크린샷 2024-04-16 오후 6 23 55" src="https://github.com/junhyeok030213/computer_network/assets/106813806/aac0ce42-bbb3-43ba-88b6-aa44fd00aaa8">

># 예 7.24
## 그림 7.38은 전환 테이블에 액세스하기 위해 레이블을 사용하는 간단한 예를 보여줍니다. 레이블은 테이블의 인덱스로 사용되므로 테이블에서 정보를 찾는 것은 즉시 가능합니다.

># 그림 7.38 예제 7.24
<img width="658" alt="스크린샷 2024-04-16 오후 6 24 54" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a1b8ce82-c138-4a79-a5ae-a522b0f156ba">

># A New Header(새 헤더)
## IP와 같은 프로토콜을 사용하여 연결 지향 스위칭을 시뮬레이션하기 위해서는 먼저 뒤에서 설명하는 라벨을 운반하는 필드를 패킷에 추가하는 것이 필요합니다. IPv4 패킷 형식에서는 이러한 확장이 허용되지 않습니다. 해결책은 IPv4 패킷을 MPLS(multi protocol label switching) 패킷에 캡슐화하는 것입니다. 그림 7.39는 캡슐화를 보여줍니다.
## MPLS 헤더는 실제로 서브 헤더들의 스택으로서, 앞으로 설명하겠지만 다단계 계층 스위칭에 사용됩니다. 그림 7.40은 각 서브 헤더의 길이가 32비트(4바이트)인 MPLS 헤더의 포맷을 보여줍니다.

># 그림 7.39 IP 패킷에 추가된 MPLS 헤더
<img width="838" alt="스크린샷 2024-04-16 오후 6 25 56" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a8ad641f-ca13-4c0b-ae22-50365b652fe1">

># 그림 7.40 라벨 스택으로 이루어진 MPLS 헤더
<img width="834" alt="스크린샷 2024-04-16 오후 6 26 15" src="https://github.com/junhyeok030213/computer_network/assets/106813806/30a93568-eea8-4f63-9e50-c4728b32c378">

># 계층적 전환
## MPLS의 라벨 스택은 계층적 스위칭을 가능하게 합니다. 이는 기존의 계층적 라우팅과 유사합니다. 
## 예를 들어, 두 개의 레이블이 있는 패킷은 맨 위 레이블을 사용하여 조직 외부의 스위치를 통해 패킷을 전달할 수 있습니다. 맨 아래 레이블은 대상 서브넷에 도달하기 위해 조직 내부의 패킷을 라우팅하는 데 사용할 수 있습니다.
