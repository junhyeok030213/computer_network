># 7-4 인터넷 프로토콜 버전 4

## 인터넷의 네트워크 계층은 여러 버전을 거쳤지만 IP 버전 4(IPv4)와 IP 버전 6(IPv6)의 두 가지 버전만 살아 남았다.
## IPv4는 거의 고갈되었지만 아직 이 버전을 사용하는 영역이 있고 IPv6의 기반이기 때문에 이에 대해 논의한다.

># 7.4.1 IPv4 주소 지정
## 각 장치의 인터넷 연결을 식별하기 위해 TCP/IP 프로토콜 제품군의 IP 계층에서 사용되는 식별자를 인터넷 주소 또는 IP 주소라고 한다.
## IPv4 주소는 호스트나 라우터의 인터넷 연결을 고유하고 보편적으로 정의하는 32비트 주소이다.
## IP 주소는 호스트나 라우터가 아닌 연결 주소이다.
## ICANN(Internet Corporation for Assigned Names and Numbers)이 IP 주소를 관리하고 있다.

># 주소 공간(Adress Space)
## 주소 공간은 프로토콜이 사용하는 주소의 총 개수이다.
## 프로토콜이 주소를 정의하기 위해 b 비트를 사용하는 경우 각 비트가 두 가지 다른 값(0 또는 1)을 가질 수 있으므로 주소 공간은 2^b이다.
## IPv4는 32비트 주소를 사용한다. 즉, 주소 공간은 2^32 또는 4,294,967,296(40억 이상)이다.
## 제한이 없다면 40억 개 이상의 장치가 인터넷에 연결될 수 있다.

># 표기법
## IPv4 주소를 표시하기 위한 일반적인 표기법은 이진 표기법(베이스 2), 점선 10진 표기법(베이스 256), 16진 표기법(베이스 16) 세 가지가 있습니다.

># 그림 7.4 IPv4 주소 지정에서 세 가지 다른 표기법
<img width="848" alt="스크린샷 2024-04-15 오후 11 39 50" src="https://github.com/junhyeok030213/computer_network/assets/106813806/85b7aa57-d3db-44f8-b6d8-7e8b446f602e">

># 주소 지정의 계층 구조
## 전화 네트워크나 우편 네트워크와 같이 배달과 관련된 모든 통신 네트워크에서 주소 지정 시스템은 계층적이다.
## 32비트 IPv4 주소도 계층적이지만 두 부분으로만 나누어 진다.
## 접두사라고 하는 주소의 첫 번째 부분은 네트워크를 정의한다. 접미사라고 하는 주소의 두번째 부분은 노드를 정의한다.

># 그림 7.5 주소 지정의 계층 구조
<img width="828" alt="스크린샷 2024-04-15 오후 11 53 26" src="https://github.com/junhyeok030213/computer_network/assets/106813806/6dba722a-f56c-421a-9412-4a79fb83d122">

># Classful Addressing(품격있는? 주소지정)
## 인터넷이 시작될 때 IPv4 주소는 고정 길이 접두사로 설계되었으나 크고 작은 네트워크를 모두 수용하기 위해 하나가 아닌 3개의 고정 길이 접두사(n=8, n=16, n=24)로 설계되었다.
## 전체 주소 공간은 그림 7.6과 같이 5개의 클래스(클래스 A, B, C, D, E)로 구분된다.
## 이 체계를 클래스형 주소 지정이라고 한다.
## 클래스형 주소 지정은 과거의 일이지만 나중에 설명할 클래스 없는 주소지정을 이해하는데 도움이 된다.

># 그림 7.6 클래스 주소 지정에서 주소 공간의 점유
<img width="846" alt="스크린샷 2024-04-15 오후 11 58 08" src="https://github.com/junhyeok030213/computer_network/assets/106813806/71683e21-f6ca-407d-921f-680fcccfa272">

># 클래스 없는 주소 지정
## 인터넷이 성장함에 따라 장기적인 솔루션으로 더 큰 주소 공간이 필요하다는 것이 분명해졌다.
## 그러나 주소 공간이 커지면 IP 주소의 길이도 길어져야 하며, 이는 IP 패킷의 형식을 변경해야 함을 의미한다.
## 장기적인 솔루션이 이미 고안되어 IPv6라고 불리지만, 동일한 주소 공간을 사용하되 주소 분포를 변경하여 각 조직에 공정한 공유를 제공하는 단기 솔루션도 고안되었다.
## 단기 솔루션은 여전히 IPv4 주소를 사용하지만 이를 클래스 없는 주소 지정이라고 한다.

># 그림 7.7 클래스 없는 주소 지정에서 가변 길이 블록
><img width="842" alt="스크린샷 2024-04-16 오전 12 01 40" src="https://github.com/junhyeok030213/computer_network/assets/106813806/8dcf68a4-bb4b-4737-a947-79bffcf4f98a">

># 그림 7.8 슬래시 표기법(CIDR)
## CIDR: Classless InterDomain Routing -> 사이더로 발음 (cider)]
<img width="849" alt="스크린샷 2024-04-16 오전 12 02 29" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a4d6954b-7b8f-46fa-b4b5-02ea553d00f8">

># 클래스리스 어드레싱에서 정보 추출
<img width="830" alt="스크린샷 2024-04-16 오전 12 03 03" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b950c47b-a936-43a8-8c67-21a7e3e4356b">

># 예제 7.1
## 클래스 없는 주소는 167.199.170.82/27로 지정된다. 위에 세가지 정보는 다음과 같이 확인할 수 있다. 네트워크의 주소 수는 2^32-n = 25 = 32개 주소이다. 첫 번째 주소는 처음 27비트를 유지하고 나머지는 비트를 0s로 변경하여 찾을 수 있다.

<img width="815" alt="스크린샷 2024-04-16 오전 12 05 24" src="https://github.com/junhyeok030213/computer_network/assets/106813806/7b2f65bf-dc02-4a23-b86a-b1e8e29d2b11">

## 마지막 주소는 처음 27비트를 유지하고 나머지 비트를 1로 변경하면 찾을 수 있다.
<img width="804" alt="스크린샷 2024-04-16 오전 12 05 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/fa07f196-3cfb-4f0a-a542-27920f55ed7d">

># 예제 7.2
## 마스크를 사용하여 예제 7.1을 반복한다. 점으로 구분된 십진수 표기법의 마스크는 256.256.256.224이다. AND, OR 및 NOT 연산은 도서 웹사이트의 계산기와 애플릿을 사용하여 개별 바이트에 적용할 수 있다.
<img width="837" alt="스크린샷 2024-04-16 오전 12 07 11" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b8b7adb6-c910-4ef7-9ef2-c877bdc04625">

># 예제 7.3
## 클래스 없는 주소 지정에서는 주소 자체가 해당 주소가 속한 블럭을 정의할 수 없다. 예를 들어 주소 230.8.24.56은 여러 블럭에 속할 수 있다. 그 중 일부는 해당 블럭과 관련된 접두사 값과 함께 아래에 표기된다.
<img width="787" alt="스크린샷 2024-04-16 오전 12 08 22" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a55f8a78-91bb-405a-b3cf-b2f5b753cc3d">

># 그림 7.9 네트워크 주소
## 네트워크 주소: 블록의 첫 번째 주소는 일반적으로 어떤 장치에도 할당되지 않습니다. 이 주소는 조직을 나머지 세계로 나타내는 네트워크 주소로 사용됩니다.
<img width="836" alt="스크린샷 2024-04-16 오전 12 09 05" src="https://github.com/junhyeok030213/computer_network/assets/106813806/6b48e484-a240-4fe5-93ea-8615ccc6ed87">

># 예제 7.4

## ISP가 1000개의 주소 블럭을 요청하였다. 1000은 2의 거듭제곱이 아니므로 1024개의 주소가 부여된다. 접두사 길이는 n = 32 - log_2 1024 = 22로 계산된다. 사용 가능한 블럭 18.14.12.0/22가 ISP에 부여된다. 10진수의 첫 번째 주소는 302,910,464로 1024로 나누어지는 것을 알 수 있다.

># 7.4.1 IPv4 주소지정: 서브네팅(Subnetting)
## 서브네팅을 사용하여 더 많은 계층을 만들 수 있다. 일정 범위의 주소를 가진 기관(혹은 ISP)은 범위를 부 범위로 나누고, 이를 서브네트워크(혹은 서브넷)에 할당할 수 있다.
## 서브넷 설계
- 기관에 할당된 전체 주소의 수를 N, 접두사의 길이를 n, 각 서브넷에 할당된 주소의 수를 N_sub, 각 서브넷의 접두사의 길이를 n_sub로 가정하자.
- 각 서브네트워크의 주소의 수는 2의 제곱승(power of 2) 이여야 한다.
- 각 서브네트워크의 접두사의 길이는 다음 공식을 이용해 구할 수 있다.
<img width="234" alt="스크린샷 2024-04-16 오전 12 15 02" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c146ff7c-8a32-4376-a3c1-9c131cc8f186">

- 각 서브네트워크의 첫 주소는 서브네트워크의 주소 수로 나눌 수 있어야 한다. 이는 더 큰 서브네트워크에 주소를 먼저 할당하면 된다.

># 예 7.5 - 1
## 조직에는 시작 주소가 14.24.74.0/24인 주소 블럭이 부여된다. 조직은 3개의 서브넷에서 사용할 3개의 주소 하위 블럭(10개 주소의 하위 블럭 1개, 60개 주소의 하위 블럭 1개, 120개 주소의 하위 블럭 1개)이 필요하다. 하위블럭을 디자인해라
# 해결책
## 이 블럭에는 2^(32-24) = 256 개의 주소가 있다. 첫 번째 주소는 14.24.74.0/24이다. 마지막 주소는 14.24.74.255/24이다. 세 번째 요구 사항을 충족하기 위해 가장 큰 것부터 시작하여 가장 작은 것까지 끝나는 하위 블럭에 주소를 할당한다.

># 예 7.5 - 2
## a. 120개의 주소가 필요한 가장 큰 하위 블럭의 주소 수는 2의 거듭제곱이 아니다. 우리는 128개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 n_1 = 32 - log_2 128 =  25로 찾을 수 있다. 이 블럭의 첫 번째 주소는 14.24.74.0/25 이다. 마지막 주소는 14.24.74.127/25이다.
## b. 60개의 주소가 필요한 두 번째로 큰 하위 블럭의 주소 수 역시 2의 거듭제곱이 아니다. 우리는 64개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 n_2= 32 - log_2 64 = 26으로 찾을 있다. 이 블럭의 첫 번째 주소는 14.24.74.128/26이다. 마지막 주소는 14.24.74.191./26이다.

># 예 7.5 - 3
## c. 10개의 주소가 필요한 가장 작은 하위 블럭의 주소 수는 2의 거듭제곱이 아니다. 우리는 16개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 다음과 같이 찾을 수 있다. 이 블럭의 첫 번째 주소는 14.24.74.207/28이다.

## 이전 서브 블럭의 주소를 모두 더하면 208개의 주소가 되며, 이는 48개의 주소가 예비로 남음을 의미한다. 이 범위의 첫 번째 주소는 14.24.74.208이다. 마지막 주소는 14.24.74.255이다. 우리는 아직 접두사 길이의 대해 모른다. 그림 4.36은 블럭 구성을 보여준다. 각 블럭의 첫 번째 주소를 표시하였다.

># 그림 7.10 예제 4.5에 대한 솔루션
<img width="824" alt="스크린샷 2024-04-16 오후 1 15 03" src="https://github.com/junhyeok030213/computer_network/assets/106813806/038ae31b-4e09-4597-a0d5-03cc013cd9b8">

># 예 7.6
## 그림 7.11은 ISP에 의해 4개의 작은 주소 블록이 4개의 조직에 할당되는 방식을 보여줍니다. ISP는 이 4개의 블록을 하나의 블록으로 묶어서 더 큰 블록을 전 세계에 광고합니다. 이 더 큰 블록으로 향하는 패킷은 모두 이 ISP로 보내져야 합니다. 패킷을 적절한 조직에 전달하는 것은 ISP의 책임입니다. 이는 우리가 우편망에서 찾을 수 있는 라우팅과 유사합니다. 한 국가 밖에서 오는 모든 패키지는 먼저 수도로 전송된 다음 해당 목적지로 배포됩니다.

># 그림 7.11 주소 집계의 예
<img width="843" alt="스크린샷 2024-04-16 오후 1 16 37" src="https://github.com/junhyeok030213/computer_network/assets/106813806/420ed461-62b5-419f-bcd1-300eb7f613e2">

># DHCP(Dynamic Host Configuration Protocol - 동적 호스트 구성 프로토콜)
## 주소 블럭이 조직에 할당된 후 네트워크 관리는 개별 호스트 또는 라우터에 주소를 수동으로 할당할 수 있다.
## 그러나 조직 내 주소 할당은 DHCP(동적 호스트 구성 프로토콜)를 사용하여 자동으롤 수행될 수 있다.
## DHCP는 클라이언트-서버 패러다임을 사용하는 응용 프로그램 계층 프로그램으로 네트워크 계층에서 실제로 TCP/IP를 지원한다.

># DHCP 메시지 형식
<img width="372" alt="스크린샷 2024-04-16 오후 1 20 48" src="https://github.com/junhyeok030213/computer_network/assets/106813806/0fa18c78-ea9a-4a22-bbe2-d6a44d3621e9">

## Fields:
- Opcode: 작업 코드, 요청(1) 또는 요청(2)
- Htype: 하드웨어 유형(이더넷, ...)
- HLen: 하드웨어 주소의 길이
- HCount: 패킷이 이동할 수 있는 최대 홉 수
- Transaction ID: 클라이언트가 설정하고 서버가 반복하는 정수
- Time elaped(경과 시간): 클라이언트가 부팅을 시작한 이후 경과한 시간(초)
- Flags(플래그): 첫 번째 비트는 유니캐스트(0) 또는 멀티캐스트(1)를 정의한다. 다른 15비트는 사용되지 않는다.
- 클라이언트 IP 주소: 클라이언트가 이를 모르는 경우 0으로 설정
- Your IP 주소: 서버가 보낸 클라이언트 IP 주소
- 게이트웨이 IP 주소: 기본 라우터의 주소
- 서버 이름: 서버의 64바이트 도메인 이름
- 부팅 파일 이름: 추가 정보가 포함된 128바이트 파일 이름
- 옵션: 텍스트로 설명된 이중 목적을 가진 64바이트 필드

># 옵션 형식
<img width="625" alt="스크린샷 2024-04-16 오후 1 29 44" src="https://github.com/junhyeok030213/computer_network/assets/106813806/614aee52-6b49-4525-802e-dc5825ba2829">

># DHCP 옵션
<img width="734" alt="스크린샷 2024-04-16 오후 1 30 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c9aaa980-f97f-48d9-a3a4-ed01a1f831ac">

># 18.4.5 NAT
<img width="769" alt="스크린샷 2024-04-16 오후 1 34 27" src="https://github.com/junhyeok030213/computer_network/assets/106813806/eacabbae-1990-43b8-88f9-491d4eb9f7dd">

## 대부분의 경우 소규모 네트워크에 있는 컴퓨터 중 일부만 동시에 인터넷 액세스해야 함
## 개인 주소와 범용 주소 간의 매핑을 제공하는 동시에 가상 사설망을 지원할 수 있는 기술이 NAT(Network Address Translation)이다.
## 이 기술을 통해 사이트는 내부 통신을 위해 일련의 개인 주소를 사용하고 나머지 세계와의 통신을 위해 일련의 글로벌 인터넷 주소(최소 하나)를 사용할 수 있다.

># 주소번역
<img width="841" alt="스크린샷 2024-04-16 오후 1 34 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/39a5c9a9-42fb-4917-b6b2-d5d8337c5b3c">

># Translation
<img width="843" alt="스크린샷 2024-04-16 오후 1 36 45" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d9b08dc6-9155-4b9b-bd42-92cca53c6bd6">

># Five-column translation table(오열통역표)
<img width="809" alt="스크린샷 2024-04-16 오후 1 37 24" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b41e7749-5e08-4e07-be02-a95525de485f">

># 7.4.2 4가지 관련 프로토콜(Main and Auxiliary(보조의) Protocols)
## IPv4 프로토콜
- Packetizing(패킷화)
- Forwarding(포워딩)
- Delivery of a packet(패킷 전달)
## ICMPv4(Internet Control Message Protocol Version 4)
- IPv4를 도와 네트워크층의 전송 중 발생할 수 있는 오류를 제어함
## IGMP(Internet Group Management Protocol)
- IPv4의 멀티캐스트를 도와줌
## ARP(Address Resolution Protocol)
- 네트워크층 주소와 링크 계층 주소를 매핑

># 그림 7.12 TCP/IP 프로토콜 스위트에서 IP 및 기타 네트워크 계층 프로토콜의 위치
<img width="835" alt="스크린샷 2024-04-16 오후 1 45 51" src="https://github.com/junhyeok030213/computer_network/assets/106813806/792f3781-18fe-4a0b-8e12-2111bd98d984">

># IPv4의 특성
## 신뢰할 수 없고 연결되지 않음
## 최선의 배송 서비스: 오류 제어 또는 흐름 제어 없음(헤더 오류 및 감지 제외)
## 최고의 전송이지만 보장할 수는 없다.
## 안정적인 전송이 필요한 경우 IPv6는 TCP와 긴밀하게 작동한다.
## IPv4 계층의 패킷을 데이터그램이라고 한다.

># 데이터그램 형식
## IP가 사용하는 패킷을 데이터그램이라고 한다.
## 그림 7.13은 IPv4 데이터그램 형식을 보여준다.
## 데이터그램은 헤더와 페이로드(데이터) 두 부분으로 구성된 가변길이 패킷이다.
## 헤더의 길이는 20~60바이트이며 라우팅 및 전달에 필수적인 정보를 포함한다.
## TCP/IP에서는 헤더를 4바이트 섹션으로 표시하는 것이 관례이다.

># 그림 7.13 IP 데이터그램
<img width="734" alt="스크린샷 2024-04-16 오후 1 51 34" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d154ebfe-82f8-4a42-adc6-055b377f2a15">

># IPv4 데이터그램 형식
## 버전(VER): 사용된 프로토콜 버전을 나타낸다.
## 헤더 길이(HLEN): 총 길이(4바이트 워드), 헤더 길이는 20~60바이트 사이에서 가변적입니다. 예를 들어, 20바이트의 경우 HLEN 5의 값이다.
## 서비스: IETF는 서비스 유형에서 차별화된 서비스로 이름을 변경하였다.
<img width="653" alt="스크린샷 2024-04-16 오후 2 03 12" src="https://github.com/junhyeok030213/computer_network/assets/106813806/eaa4d689-a040-42ea-b4d8-c5030e624645">

## 식별: 조각화에 사용된다.
- 시퀀스 번호
- 데이터그램을 고유하게 식별하기 위해 주소 및 사용자 프로토콜과 함께 사용된다.(IP 주소 + 시퀀스 번호)
## 플래그: 조각화에 사용된다.
## 조각화 오프셋: 조각화에 사용된다.
## 생존 시간: 인터넷을 통한 여행의 제한된 수명
- 홉 수(보통 소스와 대상 간 최대 라우터 수의 2배)
- 데이터그램이 라우터를 방문할 때마다 1씩 감소

># 7.4.2 데이터그램 형식: 헤더 필드(3)
## 헤더 검사합(Header checksum): 16 bits
- 각 라우터에서 확인 및 재계산
- 16비트 1은 헤더의 모든 16비트 워드의 합을 보완합니다
- 계산 중에 0으로 설정

## 발신지 주소(Source address): 32 bits
## 목적지 주소(Destination address): 32 bits
## 선택사항(Options): 네트워크 테스트/디버깅에 사용됨
## 패딩(Padding): 길이 32비트의 배수로 채우기
## 페이로드(Payload):
- 상위 계층의 사용자 데이터 전달
- 8 비트 길이(octet)의 정수 배
- 데이터그램의 최대 길이(헤더 + 데이터)는 65.535 octets

  
