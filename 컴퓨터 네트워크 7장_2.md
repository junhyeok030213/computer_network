># 7-4 인터넷 프로토콜 버전 4

## 인터넷의 네트워크 계층은 여러 버전을 거쳤지만 IP 버전 4(IPv4)와 IP 버전 6(IPv6)의 두 가지 버전만 살아 남았다.
## IPv4는 거의 고갈되었지만 아직 이 버전을 사용하는 영역이 있고 IPv6의 기반이기 때문에 이에 대해 논의한다.

># 7.4.1 IPv4 주소 지정
## 각 장치의 인터넷 연결을 식별하기 위해 TCP/IP 프로토콜 제품군의 IP 계층에서 사용되는 식별자를 인터넷 주소 또는 IP 주소라고 한다.
## IPv4 주소는 호스트나 라우터의 인터넷 연결을 고유하고 보편적으로 정의하는 32비트 주소이다.
## IP 주소는 호스트나 라우터가 아닌 연결 주소이다.
## ICANN(Internet Corporation for Assigned Names and Numbers)이 IP 주소를 관리하고 있다.

># 주소 공간(Adress Space)
## 주소 공간은 프로토콜이 사용하는 주소의 총 개수이다.
## 프로토콜이 주소를 정의하기 위해 b 비트를 사용하는 경우 각 비트가 두 가지 다른 값(0 또는 1)을 가질 수 있으므로 주소 공간은 2^b이다.
## IPv4는 32비트 주소를 사용한다. 즉, 주소 공간은 2^32 또는 4,294,967,296(40억 이상)이다.
## 제한이 없다면 40억 개 이상의 장치가 인터넷에 연결될 수 있다.

># 표기법
## IPv4 주소를 표시하기 위한 일반적인 표기법은 이진 표기법(베이스 2), 점선 10진 표기법(베이스 256), 16진 표기법(베이스 16) 세 가지가 있습니다.

># 그림 7.4 IPv4 주소 지정에서 세 가지 다른 표기법
<img width="848" alt="스크린샷 2024-04-15 오후 11 39 50" src="https://github.com/junhyeok030213/computer_network/assets/106813806/85b7aa57-d3db-44f8-b6d8-7e8b446f602e">

># 주소 지정의 계층 구조
## 전화 네트워크나 우편 네트워크와 같이 배달과 관련된 모든 통신 네트워크에서 주소 지정 시스템은 계층적이다.
## 32비트 IPv4 주소도 계층적이지만 두 부분으로만 나누어 진다.
## 접두사라고 하는 주소의 첫 번째 부분은 네트워크를 정의한다. 접미사라고 하는 주소의 두번째 부분은 노드를 정의한다.

># 그림 7.5 주소 지정의 계층 구조
<img width="828" alt="스크린샷 2024-04-15 오후 11 53 26" src="https://github.com/junhyeok030213/computer_network/assets/106813806/6dba722a-f56c-421a-9412-4a79fb83d122">

># Classful Addressing(품격있는? 주소지정)
## 인터넷이 시작될 때 IPv4 주소는 고정 길이 접두사로 설계되었으나 크고 작은 네트워크를 모두 수용하기 위해 하나가 아닌 3개의 고정 길이 접두사(n=8, n=16, n=24)로 설계되었다.
## 전체 주소 공간은 그림 7.6과 같이 5개의 클래스(클래스 A, B, C, D, E)로 구분된다.
## 이 체계를 클래스형 주소 지정이라고 한다.
## 클래스형 주소 지정은 과거의 일이지만 나중에 설명할 클래스 없는 주소지정을 이해하는데 도움이 된다.

># 그림 7.6 클래스 주소 지정에서 주소 공간의 점유
<img width="846" alt="스크린샷 2024-04-15 오후 11 58 08" src="https://github.com/junhyeok030213/computer_network/assets/106813806/71683e21-f6ca-407d-921f-680fcccfa272">

># 클래스 없는 주소 지정
## 인터넷이 성장함에 따라 장기적인 솔루션으로 더 큰 주소 공간이 필요하다는 것이 분명해졌다.
## 그러나 주소 공간이 커지면 IP 주소의 길이도 길어져야 하며, 이는 IP 패킷의 형식을 변경해야 함을 의미한다.
## 장기적인 솔루션이 이미 고안되어 IPv6라고 불리지만, 동일한 주소 공간을 사용하되 주소 분포를 변경하여 각 조직에 공정한 공유를 제공하는 단기 솔루션도 고안되었다.
## 단기 솔루션은 여전히 IPv4 주소를 사용하지만 이를 클래스 없는 주소 지정이라고 한다.

># 그림 7.7 클래스 없는 주소 지정에서 가변 길이 블록
><img width="842" alt="스크린샷 2024-04-16 오전 12 01 40" src="https://github.com/junhyeok030213/computer_network/assets/106813806/8dcf68a4-bb4b-4737-a947-79bffcf4f98a">

># 그림 7.8 슬래시 표기법(CIDR)
## CIDR: Classless InterDomain Routing -> 사이더로 발음 (cider)]
<img width="849" alt="스크린샷 2024-04-16 오전 12 02 29" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a4d6954b-7b8f-46fa-b4b5-02ea553d00f8">

># 클래스리스 어드레싱에서 정보 추출
<img width="830" alt="스크린샷 2024-04-16 오전 12 03 03" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b950c47b-a936-43a8-8c67-21a7e3e4356b">

># 예제 7.1
## 클래스 없는 주소는 167.199.170.82/27로 지정된다. 위에 세가지 정보는 다음과 같이 확인할 수 있다. 네트워크의 주소 수는 2^32-n = 25 = 32개 주소이다. 첫 번째 주소는 처음 27비트를 유지하고 나머지는 비트를 0s로 변경하여 찾을 수 있다.

<img width="815" alt="스크린샷 2024-04-16 오전 12 05 24" src="https://github.com/junhyeok030213/computer_network/assets/106813806/7b2f65bf-dc02-4a23-b86a-b1e8e29d2b11">

## 마지막 주소는 처음 27비트를 유지하고 나머지 비트를 1로 변경하면 찾을 수 있다.
<img width="804" alt="스크린샷 2024-04-16 오전 12 05 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/fa07f196-3cfb-4f0a-a542-27920f55ed7d">

># 예제 7.2
## 마스크를 사용하여 예제 7.1을 반복한다. 점으로 구분된 십진수 표기법의 마스크는 256.256.256.224이다. AND, OR 및 NOT 연산은 도서 웹사이트의 계산기와 애플릿을 사용하여 개별 바이트에 적용할 수 있다.
<img width="837" alt="스크린샷 2024-04-16 오전 12 07 11" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b8b7adb6-c910-4ef7-9ef2-c877bdc04625">

># 예제 7.3
## 클래스 없는 주소 지정에서는 주소 자체가 해당 주소가 속한 블럭을 정의할 수 없다. 예를 들어 주소 230.8.24.56은 여러 블럭에 속할 수 있다. 그 중 일부는 해당 블럭과 관련된 접두사 값과 함께 아래에 표기된다.
<img width="787" alt="스크린샷 2024-04-16 오전 12 08 22" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a55f8a78-91bb-405a-b3cf-b2f5b753cc3d">

># 그림 7.9 네트워크 주소
## 네트워크 주소: 블록의 첫 번째 주소는 일반적으로 어떤 장치에도 할당되지 않습니다. 이 주소는 조직을 나머지 세계로 나타내는 네트워크 주소로 사용됩니다.
<img width="836" alt="스크린샷 2024-04-16 오전 12 09 05" src="https://github.com/junhyeok030213/computer_network/assets/106813806/6b48e484-a240-4fe5-93ea-8615ccc6ed87">

># 예제 7.4

## ISP가 1000개의 주소 블럭을 요청하였다. 1000은 2의 거듭제곱이 아니므로 1024개의 주소가 부여된다. 접두사 길이는 n = 32 - log_2 1024 = 22로 계산된다. 사용 가능한 블럭 18.14.12.0/22가 ISP에 부여된다. 10진수의 첫 번째 주소는 302,910,464로 1024로 나누어지는 것을 알 수 있다.

># 7.4.1 IPv4 주소지정: 서브네팅(Subnetting)
## 서브네팅을 사용하여 더 많은 계층을 만들 수 있다. 일정 범위의 주소를 가진 기관(혹은 ISP)은 범위를 부 범위로 나누고, 이를 서브네트워크(혹은 서브넷)에 할당할 수 있다.
## 서브넷 설계
- 기관에 할당된 전체 주소의 수를 N, 접두사의 길이를 n, 각 서브넷에 할당된 주소의 수를 N_sub, 각 서브넷의 접두사의 길이를 n_sub로 가정하자.
- 각 서브네트워크의 주소의 수는 2의 제곱승(power of 2) 이여야 한다.
- 각 서브네트워크의 접두사의 길이는 다음 공식을 이용해 구할 수 있다.
<img width="234" alt="스크린샷 2024-04-16 오전 12 15 02" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c146ff7c-8a32-4376-a3c1-9c131cc8f186">

- 각 서브네트워크의 첫 주소는 서브네트워크의 주소 수로 나눌 수 있어야 한다. 이는 더 큰 서브네트워크에 주소를 먼저 할당하면 된다.

># 예 7.5 - 1
## 조직에는 시작 주소가 14.24.74.0/24인 주소 블럭이 부여된다. 조직은 3개의 서브넷에서 사용할 3개의 주소 하위 블럭(10개 주소의 하위 블럭 1개, 60개 주소의 하위 블럭 1개, 120개 주소의 하위 블럭 1개)이 필요하다. 하위블럭을 디자인해라
# 해결책
## 이 블럭에는 2^(32-24) = 256 개의 주소가 있다. 첫 번째 주소는 14.24.74.0/24이다. 마지막 주소는 14.24.74.255/24이다. 세 번째 요구 사항을 충족하기 위해 가장 큰 것부터 시작하여 가장 작은 것까지 끝나는 하위 블럭에 주소를 할당한다.

># 예 7.5 - 2
## a. 120개의 주소가 필요한 가장 큰 하위 블럭의 주소 수는 2의 거듭제곱이 아니다. 우리는 128개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 n_1 = 32 - log_2 128 =  25로 찾을 수 있다. 이 블럭의 첫 번째 주소는 14.24.74.0/25 이다. 마지막 주소는 14.24.74.127/25이다.
## b. 60개의 주소가 필요한 두 번째로 큰 하위 블럭의 주소 수 역시 2의 거듭제곱이 아니다. 우리는 64개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 n_2= 32 - log_2 64 = 26으로 찾을 있다. 이 블럭의 첫 번째 주소는 14.24.74.128/26이다. 마지막 주소는 14.24.74.191./26이다.

># 예 7.5 - 3
## c. 10개의 주소가 필요한 가장 작은 하위 블럭의 주소 수는 2의 거듭제곱이 아니다. 우리는 16개의 주소를 할당한다. 이 서브넷의 서브넷 마스크는 다음과 같이 찾을 수 있다. 이 블럭의 첫 번째 주소는 14.24.74.207/28이다.

## 이전 서브 블럭의 주소를 모두 더하면 208개의 주소가 되며, 이는 48개의 주소가 예비로 남음을 의미한다. 이 범위의 첫 번째 주소는 14.24.74.208이다. 마지막 주소는 14.24.74.255이다. 우리는 아직 접두사 길이의 대해 모른다. 그림 4.36은 블럭 구성을 보여준다. 각 블럭의 첫 번째 주소를 표시하였다.

># 그림 7.10 예제 4.5에 대한 솔루션
<img width="824" alt="스크린샷 2024-04-16 오후 1 15 03" src="https://github.com/junhyeok030213/computer_network/assets/106813806/038ae31b-4e09-4597-a0d5-03cc013cd9b8">

># 예 7.6
## 그림 7.11은 ISP에 의해 4개의 작은 주소 블록이 4개의 조직에 할당되는 방식을 보여줍니다. ISP는 이 4개의 블록을 하나의 블록으로 묶어서 더 큰 블록을 전 세계에 광고합니다. 이 더 큰 블록으로 향하는 패킷은 모두 이 ISP로 보내져야 합니다. 패킷을 적절한 조직에 전달하는 것은 ISP의 책임입니다. 이는 우리가 우편망에서 찾을 수 있는 라우팅과 유사합니다. 한 국가 밖에서 오는 모든 패키지는 먼저 수도로 전송된 다음 해당 목적지로 배포됩니다.

># 그림 7.11 주소 집계의 예
<img width="843" alt="스크린샷 2024-04-16 오후 1 16 37" src="https://github.com/junhyeok030213/computer_network/assets/106813806/420ed461-62b5-419f-bcd1-300eb7f613e2">

># DHCP(Dynamic Host Configuration Protocol - 동적 호스트 구성 프로토콜)
## 주소 블럭이 조직에 할당된 후 네트워크 관리는 개별 호스트 또는 라우터에 주소를 수동으로 할당할 수 있다.
## 그러나 조직 내 주소 할당은 DHCP(동적 호스트 구성 프로토콜)를 사용하여 자동으롤 수행될 수 있다.
## DHCP는 클라이언트-서버 패러다임을 사용하는 응용 프로그램 계층 프로그램으로 네트워크 계층에서 실제로 TCP/IP를 지원한다.

># DHCP 메시지 형식
<img width="372" alt="스크린샷 2024-04-16 오후 1 20 48" src="https://github.com/junhyeok030213/computer_network/assets/106813806/0fa18c78-ea9a-4a22-bbe2-d6a44d3621e9">

## Fields:
- Opcode: 작업 코드, 요청(1) 또는 요청(2)
- Htype: 하드웨어 유형(이더넷, ...)
- HLen: 하드웨어 주소의 길이
- HCount: 패킷이 이동할 수 있는 최대 홉 수
- Transaction ID: 클라이언트가 설정하고 서버가 반복하는 정수
- Time elaped(경과 시간): 클라이언트가 부팅을 시작한 이후 경과한 시간(초)
- Flags(플래그): 첫 번째 비트는 유니캐스트(0) 또는 멀티캐스트(1)를 정의한다. 다른 15비트는 사용되지 않는다.
- 클라이언트 IP 주소: 클라이언트가 이를 모르는 경우 0으로 설정
- Your IP 주소: 서버가 보낸 클라이언트 IP 주소
- 게이트웨이 IP 주소: 기본 라우터의 주소
- 서버 이름: 서버의 64바이트 도메인 이름
- 부팅 파일 이름: 추가 정보가 포함된 128바이트 파일 이름
- 옵션: 텍스트로 설명된 이중 목적을 가진 64바이트 필드

># 옵션 형식
<img width="625" alt="스크린샷 2024-04-16 오후 1 29 44" src="https://github.com/junhyeok030213/computer_network/assets/106813806/614aee52-6b49-4525-802e-dc5825ba2829">

># DHCP 옵션
<img width="734" alt="스크린샷 2024-04-16 오후 1 30 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c9aaa980-f97f-48d9-a3a4-ed01a1f831ac">

># 18.4.5 NAT
<img width="769" alt="스크린샷 2024-04-16 오후 1 34 27" src="https://github.com/junhyeok030213/computer_network/assets/106813806/eacabbae-1990-43b8-88f9-491d4eb9f7dd">

## 대부분의 경우 소규모 네트워크에 있는 컴퓨터 중 일부만 동시에 인터넷 액세스해야 함
## 개인 주소와 범용 주소 간의 매핑을 제공하는 동시에 가상 사설망을 지원할 수 있는 기술이 NAT(Network Address Translation)이다.
## 이 기술을 통해 사이트는 내부 통신을 위해 일련의 개인 주소를 사용하고 나머지 세계와의 통신을 위해 일련의 글로벌 인터넷 주소(최소 하나)를 사용할 수 있다.

># 주소번역
<img width="841" alt="스크린샷 2024-04-16 오후 1 34 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/39a5c9a9-42fb-4917-b6b2-d5d8337c5b3c">

># Translation
<img width="843" alt="스크린샷 2024-04-16 오후 1 36 45" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d9b08dc6-9155-4b9b-bd42-92cca53c6bd6">

># Five-column translation table(오열통역표)
<img width="809" alt="스크린샷 2024-04-16 오후 1 37 24" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b41e7749-5e08-4e07-be02-a95525de485f">

># 7.4.2 4가지 관련 프로토콜(Main and Auxiliary(보조의) Protocols)
## IPv4 프로토콜
- Packetizing(패킷화)
- Forwarding(포워딩)
- Delivery of a packet(패킷 전달)
## ICMPv4(Internet Control Message Protocol Version 4)
- IPv4를 도와 네트워크층의 전송 중 발생할 수 있는 오류를 제어함
## IGMP(Internet Group Management Protocol)
- IPv4의 멀티캐스트를 도와줌
## ARP(Address Resolution Protocol)
- 네트워크층 주소와 링크 계층 주소를 매핑

># 그림 7.12 TCP/IP 프로토콜 스위트에서 IP 및 기타 네트워크 계층 프로토콜의 위치
<img width="835" alt="스크린샷 2024-04-16 오후 1 45 51" src="https://github.com/junhyeok030213/computer_network/assets/106813806/792f3781-18fe-4a0b-8e12-2111bd98d984">

># IPv4의 특성
## 신뢰할 수 없고 연결되지 않음
## 최선의 배송 서비스: 오류 제어 또는 흐름 제어 없음(헤더 오류 및 감지 제외)
## 최고의 전송이지만 보장할 수는 없다.
## 안정적인 전송이 필요한 경우 IPv6는 TCP와 긴밀하게 작동한다.
## IPv4 계층의 패킷을 데이터그램이라고 한다.

># 데이터그램 형식
## IP가 사용하는 패킷을 데이터그램이라고 한다.
## 그림 7.13은 IPv4 데이터그램 형식을 보여준다.
## 데이터그램은 헤더와 페이로드(데이터) 두 부분으로 구성된 가변길이 패킷이다.
## 헤더의 길이는 20~60바이트이며 라우팅 및 전달에 필수적인 정보를 포함한다.
## TCP/IP에서는 헤더를 4바이트 섹션으로 표시하는 것이 관례이다.

># 그림 7.13 IP 데이터그램
<img width="734" alt="스크린샷 2024-04-16 오후 1 51 34" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d154ebfe-82f8-4a42-adc6-055b377f2a15">

># IPv4 데이터그램 형식
## 버전(VER): 사용된 프로토콜 버전을 나타낸다.
## 헤더 길이(HLEN): 총 길이(4바이트 워드), 헤더 길이는 20~60바이트 사이에서 가변적입니다. 예를 들어, 20바이트의 경우 HLEN 5의 값이다.
## 서비스: IETF는 서비스 유형에서 차별화된 서비스로 이름을 변경하였다.
<img width="653" alt="스크린샷 2024-04-16 오후 2 03 12" src="https://github.com/junhyeok030213/computer_network/assets/106813806/eaa4d689-a040-42ea-b4d8-c5030e624645">

## 식별: 조각화에 사용된다.
- 시퀀스 번호
- 데이터그램을 고유하게 식별하기 위해 주소 및 사용자 프로토콜과 함께 사용된다.(IP 주소 + 시퀀스 번호)
## 플래그: 조각화에 사용된다.
## 조각화 오프셋: 조각화에 사용된다.
## 생존 시간: 인터넷을 통한 여행의 제한된 수명
- 홉 수(보통 소스와 대상 간 최대 라우터 수의 2배)
- 데이터그램이 라우터를 방문할 때마다 1씩 감소

># 7.4.2 데이터그램 형식: 헤더 필드(3)
## 헤더 검사합(Header checksum): 16 bits
- 각 라우터에서 확인 및 재계산
- 16비트 1은 헤더의 모든 16비트 워드의 합을 보완합니다
- 계산 중에 0으로 설정

## 발신지 주소(Source address): 32 bits
## 목적지 주소(Destination address): 32 bits
## 선택사항(Options): 네트워크 테스트/디버깅에 사용됨
## 패딩(Padding): 길이 32비트의 배수로 채우기
## 페이로드(Payload):
- 상위 계층의 사용자 데이터 전달
- 8 비트 길이(octet)의 정수 배
- 데이터그램의 최대 길이(헤더 + 데이터)는 65.535 octets

># 그림 7.14 프로토콜 필드 값을 이용한 다중화 및 역다중화
<img width="849" alt="스크린샷 2024-04-16 오후 2 13 52" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b5ccd17d-4dc3-4c1f-8ec3-d5fc3f69d94d">

># 예 7.7
## 처음 8비트가 (01000010)_2인 IPv4 패킷이 도착했다. 수신자는 패킷을 왜 폐기하는가?
# 해결책
## 이 패킷에 오류가 있다. 가장 왼쪽의 4비트(0010)_2는 올바른 버전을 표시한다. 다음 4비트(0010)_2는 잘못된 헤더길이(2*4=8)를 나타낸다. 헤더의 최소 바이트 수는 20이어야 한다. 패킷이 전송중에 손상되었다.

># 예 7.8
## IPv4 패킷에서 HLEN 값은 (1000)_2 이다. 이 패킷에는 몇 바이트 옵션이 전달되나?
# 해결책
## HLEN 값은 8이다. 이는 헤더의 총 바이트 수가 8*4, 즉 32바이트임을 의미한다. 처음 20바이트는 기본 헤더이고 다음 12바이트는 옵션이다.

># 예 7.9
## IPv4 패킷에서 HLEN의 값은 5이고, 전체 길이 필드의 값은 (0028)_16이다. 이 패킷에는 몇 바이트의 데이터가 전달 되는가?
# 해결책
## HLEN 값은 5다. 이는 헤더의 총 바이트 수가 5*4, 즉 20바이트(옵션 없음)임을 의미한다. 총 길이는 (0028)_16 또는 40바이트이다. 이는 패킷이 20바이트의 데이터(40-20)를 전달한다는 의미이다.

># 예 7.10
## 표시된 것처럼 처음 몇개의 16진수 숫자가 포함된 IPv4 패킷이 도착했다.
<img width="343" alt="스크린샷 2024-04-16 오후 4 13 26" src="https://github.com/junhyeok030213/computer_network/assets/106813806/bbe23877-cc69-4400-80fe-f8338c07be40">

## 이 패킷이 삭제되기 전에 몇 홉을 이동할 수 있는가? 데이터는 어떤 상위 계층 프로토콜에 속하는가?
# 해결책
## TTL(Time-To-Live)필드를 찾으려면 8바이트(16자리 16진수)를 건너뛴다. TTL(Time-To-Live) 필드는 9번째 바이트(01)_16이다. 이는 패킷이 한 홉만 이동할 수 있음을 의미한다. 프로토콜 필드는 다음 바이트(02)_16이며, 이는 상위 계층 프로토콜이 IGMP임을 의미한다.

># 예 7.11
## 그림 7.15는 옵션이 없는 IPv4 헤더에 대한 체크섬 계산 예를 보여줍니다. 헤더는 16비트 섹션으로 나뉩니다. 모든 섹션이 추가되고 가장 왼쪽 자리를 감싼 후 합산이 보완됩니다. 결과는 체크섬 필드에 삽입됩니다.

># 그림 7.15 체크섬 계산 예시
<img width="640" alt="스크린샷 2024-04-16 오후 4 17 50" src="https://github.com/junhyeok030213/computer_network/assets/106813806/f2319de7-c38b-4987-a4c6-bf047909bac0">

># Fragmentation(분열, 파쇄)
## 데이터그램은 다양한 네트워크를 통해 이동할 수 있습니다. 
## 각 라우터는 수신한 프레임에서 IP 데이터그램을 캡슐화 해제하고 처리한 다음 다른 프레임에 캡슐화합니다.
## 수신된 프레임의 형식과 크기는 프레임이 방금 이동한 물리적 네트워크에서 사용하는 프로토콜에 따라 달라집니다. 
## 전송된 프레임의 형식과 크기는 프레임이 이동할 물리적 네트워크에서 사용하는 프로토콜에 따라 달라집니다. 
## 예를 들어 라우터가 LAN을 WAN에 연결하면 LAN 형식의 프레임을 수신하고 WAN 형식의 프레임을 전송합니다.

># 최대 전송 단위
## 각 링크 계층 프로토콜에는 고유한 프레임 형식이 있습니다. 
## 각 형식의 특징 중 하나는 프레임에 캡슐화할 수 있는 페이로드의 최대 크기이며, 데이터그램의 전체 크기는 최대 크기보다 작아야 합니다(그림 7.16 참조).

># 그림 7.16 Maximum transfer unit (MTU) - 최대 전달 단위
<img width="842" alt="스크린샷 2024-04-16 오후 4 20 30" src="https://github.com/junhyeok030213/computer_network/assets/106813806/e5f5587c-59ab-417f-a5cf-fc5a080f7acf">

># 일부 네트워크의 MTU
<img width="551" alt="스크린샷 2024-04-16 오후 4 20 55" src="https://github.com/junhyeok030213/computer_network/assets/106813806/810ef01f-9f9e-4964-b8ee-b96353de9121">

># 분열
## 단편화 관련 분야
- 식별: 16비트
 
  -> 소스 호스트는 식별 및 IPv4 주소를 고유하게 정의한다.

  -> 카운터는 1을 증가시켜 각 데이터그램의 고유성을 부여하는데 사용된다.

  -> 데이터그램이 단편화되면 목적지의 재조립을 돕기 위해 각 단편은 동일한 식별 번호를 갖습니다.

- 플래그: 3비트

  -> 첫 번째 비트: 예약됨

  -> 두 번째 비트: 기계가 데이터그램을 조각내지 않아야 함을 나타내는 비트를 조각내지 마십시오. 어떤 물리적 네트워크도 데이터그램을 전달할 수 없기 때문에 소스 호스트에 ICMP 오류 메시지를 발행합니다

  -> 세 번째 비트: 이 비트 이후에 더 많은 조각이 있음을 나타내는 추가 조각 비트이다.
  
  <img width="525" alt="스크린샷 2024-04-16 오후 4 27 48" src="https://github.com/junhyeok030213/computer_network/assets/106813806/0ddbbd1d-65e5-43d4-b0ce-df7aa80ee59b">

- 조각화 오프셋: 13비트

  -> 전체 데이터그램에 대한 이 조각의 상대적 위치를 표시한다.

  -> 데이터의 오프셋은 8바이트 단위이다.

<img width="661" alt="스크린샷 2024-04-16 오후 4 31 58" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d7053996-6471-4c4e-aae7-f8f0a56d0cc5">

># 그림 7.18 상세 파편화 예시
<img width="610" alt="스크린샷 2024-04-16 오후 4 32 26" src="https://github.com/junhyeok030213/computer_network/assets/106813806/4a9ab61d-b331-4516-ac64-55cb1a27e776">

># 예 7.12
## M 비트 값이 0인 패킷이 도착했습니다. 이것은 첫 번째 조각인가요, 마지막 조각인가요, 아니면 중간 조각인가요? 패킷이 조각난 것인지 알 수 있나요?
# 해결책
## M 비트가 0이면 프래그먼트가 더 이상 없음을 의미하며 프래그먼트가 마지막 프래그먼트입니다. 그러나 원래 패킷이 프래그먼트화되었는지 여부는 말할 수 없습니다. 프래그먼트화되지 않은 패킷이 마지막 프래그먼트로 간주됩니다.

># 예 7.13
## M 비트 값이 1인 패킷이 도착했습니다. 이것은 첫 번째 조각인가요, 마지막 조각인가요, 아니면 중간 조각인가요? 패킷이 조각난 것인지 알 수 있나요?
# 해결책
## M비트가 1이면 프래그먼트가 하나 이상 더 있다는 뜻입니다. 이 프래그먼트는 처음 프래그먼트가 될 수도 있고 중간 프래그먼트가 될 수도 있지만 마지막 프래그먼트가 될 수도 없습니다. 첫 번째 프래그먼트인지 중간 프래그먼트 오프셋 값이 더 필요합니다.

># 예 7.14
## M 비트 값이 1이고 조각화 오프셋 값이 0인 패킷이 도착했습니다. 첫 번째 조각인가요, 마지막 조각인가요, 중간 조각인가요?
# 해결책
## M 비트는 1이므로 첫 번째 조각이거나 중간 조각입니다. 오프셋 값이 0이므로 첫 번째 조각입니다.

># 예 7.15
## 오프셋 값이 100인 패킷이 도착했습니다. 첫 번째 바이트의 개수는 무엇입니까? 우리는 마지막 바이트의 개수를 알고 있습니까?
# 해결책
## 첫 번째 바이트의 수를 구하기 위해서 우리는 오프셋 값에 8을 곱합니다. 이것은 첫 번째 바이트의 수가 800이라는 것을 의미합니다. 우리는 데이터의 길이를 알지 못하면 마지막 바이트의 수를 결정할 수 없습니다.

># 예 7.16
## 오프셋 값이 100, HLEN 값이 5, 전장 필드 값이 100인 패킷이 도착했습니다. 첫 번째 바이트와 마지막 바이트의 개수는 무엇입니까?
# 해결책
## 첫 번째 바이트 번호는 100 * 8 = 800입니다. 총 길이는 100 바이트이고 헤더 길이는 20 바이트 (5 * 4)이므로 이 데이터그램에는 80 바이트가 있습니다. 첫 번째 바이트 번호가 800이면 마지막 바이트 번호는 879여야 합니다.

># 7.4.3 옵션
## IPv4 데이터그램의 헤더는 고정 부분과 가변 부분의 두 부분으로 구성됩니다. 
## 고정 부품의 길이는 20바이트이며 이전 섹션에서 논의했습니다. 
## 변수 부분은 헤더의 경계를 보존하기 위해 최대 40바이트(4바이트의 배수)가 될 수 있는 옵션으로 구성됩니다.

># Options
## 최대 40바이트
## 네트워크 테스트 및 디버깅에 사용된다.
## 무작동 옵션: 1바이트, 옵션 간 채우기로 사용
## 옵션 끝 옵션: 1바이트, 패딩에 사용되며 마지막 옵션으로만 사용됨
## 라우팅 기록 옵션: 인터넷 라우터를 기록하고 최대 9개의 라우터 주소를 나열하며 디버깅 및 관리에 사용된다.
## 엄격한 소스 경로 옵션: 데이터그램의 경로를 미리 결정하기 위해 소스에서 사용된다.
- 특정 유형의 서비스가 포함된 경로
- 발신자의 목적에 맞게 더욱 안전하거나 신뢰할 수 있음
## 느슨한 소스 경로 옵션: 엄격한 소스 경로와 유사하지만 덜 엄격하므로 데이터그램이 다른 라우터도 방문할 수 있다.
## 타임스탬프 옵션: 자정부터 밀리초 단위로 표시되는 라우터의 데이터그램 처리 시간을 기록하는데 사용된다.

># IPv4의 옵션 분류
<img width="734" alt="스크린샷 2024-04-16 오후 4 48 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/01085b85-00c6-4fa3-86df-653ba13d9743">

># IPv4 데이터그램의 보안
<img width="200" alt="스크린샷 2024-04-16 오후 4 51 52" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b10adb8b-26cd-4683-8020-b92caa44a385">

## 패킷 스니핑
- 패킷을 가로채서 복사한다.
- 수동적 공격(패킷 내용 변경 없음)
- 감지하기 어려움
- 솔루션 -> 패킷 암호화

## 패킷 수정
- 패킷을 가로채서 수정한다.
- 패킷의 내용 변경
- 데이터 무결성 메커니즘을 사용하여 탐지

## IP 스푸핑
- 다른 사람으로 가장하여 IP 패킷 생성
- 예) 고객 중 한 명이 보낸 것처럼 가장하여 은행에 IP 패킷을 보낸다.
- 원본 인증 메커니즘을 사용하여 방지

># IPsec(보안)
## 공격을 보호하는 IP 보안
## 두 엔터키 간의 연결 지향 서비스
- 알고리즘 및 키 정의
- 패킷 암호화
- 데이터 무결성
- 원산지 인증

># 7.4.4 ICMPv4
## IPv4에는 오류 보고 또는 오류 수정 메커니즘이 없습니다. 
## IP 프로토콜에는 호스트 및 관리 쿼리를 위한 메커니즘도 없습니다. 
## ICMPv4(Internet Control Message Protocol version 4)는 위의 두 가지 결함을 보완하기 위해 설계되었습니다.

># 메시지
## ICMP 메시지는 오류 보고 메시지와 쿼리 메시지의 두 가지 넓은 범주로 나뉩니다. 
## 오류 보고 메시지는 라우터 또는 호스트(대상)가 IP 패킷을 처리할 때 발생할 수 있는 문제를 보고합니다. 
## 쌍으로 발생하는 쿼리 메시지는 호스트 또는 네트워크 관리자가 라우터 또는 다른 호스트에서 특정 정보를 가져오는 데 도움이 됩니다.
## 예를 들어, 노드들은 그들의 이웃들을 발견할 수 있습니다. 또한, 호스트들은 그들의 네트워크 상의 라우터들을 발견하고 배울 수 있고, 라우터들은 노드가 그들의 메시지들을 리디렉션하는 것을 도울 수 있습니다.

># 그림 7.19 ICMP 메시지의 일반 형식
<img width="848" alt="스크린샷 2024-04-16 오후 5 10 28" src="https://github.com/junhyeok030213/computer_network/assets/106813806/29d5253a-9724-4eec-afd9-5853d23eac85">

># 그림 7.20 오류 메시지의 데이터 필드 내용
<img width="838" alt="스크린샷 2024-04-16 오후 5 11 42" src="https://github.com/junhyeok030213/computer_network/assets/106813806/78ede3a5-2a20-4b08-816b-86978e8a70eb">

># 오류 보고
## 목적지에 도달할 수 없음
- 라우터가 데이터그램을 라우팅할 수 없거나 호스트가 데이터그램을 전달할 수 없는 경우 데이터그램을 삭제한 후 대상에 도달할 수 없다는 메시지를 스스로 다시 보낸다.
## 소스 퀸치
- 흐름 제어 부족을 해결하기 위해
- 라우터나 호스트가 혼잡으로 인해 데이터그램을 폐기하면 데이터그램 발신자에게 소스 퀀치 메시지를 보낸다.

 -> 데이터그램이 폐기되었음을 소스에 알린다.

 -> 경로 어딘가에 소스 정체가 있음을 경고한다.

## 시간이 초과.
- TTL 값이 0에 도달하면 라우터는 데이터그램을 폐기한 후 시간 초과 메시지를 스스로 보낸다.

## 매개변수 문제
- 라우터나 목적지가 데이터그램의 어떤 필드에서 모호하거나 누락된 값을 발견하면 데이터그램을 버린 후 매개변수 문제 메시지를 소스에 보낸다.
## Redirection(리디렉션)
<img width="827" alt="스크린샷 2024-04-16 오후 5 17 17" src="https://github.com/junhyeok030213/computer_network/assets/106813806/22181bfb-d3e7-4e36-869a-322bd03c431b">

># Query Messages(쿼리(의혹,질문) 메시지)
## 일부 네트워크 문제를 진단할 수 있습니다
<img width="833" alt="스크린샷 2024-04-16 오후 5 21 19" src="https://github.com/junhyeok030213/computer_network/assets/106813806/704441ed-7ac3-4348-a814-deb69e48aae0">

