># 7.5 차세대 IP(IPv6)
## IPv4의 주소 고갈과 이 프로토콜의 다른 단점들은 1990년대 초반에 인터넷 프로토콜 버전 6(IPv6) 또는 IP new generation(IPng)이라고 불리는 새로운 버전의 IP 프로토콜을 촉발시켰습니다.

># 7.5.1 IPv6 Addressing
## IPv4에서 IPv6로 마이그레이션한 주요 이유는 IPv4의 주소 공간의 작은 크기 때문이었습니다. 
## IPv6 주소는 IPv4 주소 길이의 4배인 128비트 또는 16바이트입니다.


># Representation(표시, 표현, 묘사)
## IPv6 주소는 128비트 또는 16바이트로 IPv4 주소 길이의 4배입니다.
<img width="690" alt="스크린샷 2024-04-18 오후 1 16 36" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d80e1948-f963-49ff-9d42-7f55786e430a">

># Abbreviation(약어)
## Zero compression(제로 압축)

># 주소 유형
## 유니캐스트 주소
- 유니캐스트 주소는 단일 인터페이스(컴퓨터 또는 라우터)를 정의함.
- 유니캐스트 주소로 전송된 패킷은 의도된 수신자에게 라우팅됨

## 애니캐스트 주소
- 애니캐스트 주소는 모두 단일 주소를 공유하는 컴퓨터 그룹을 정의함
- 애니캐스트 주소를 가진 패킷은 가장 접근하기 쉬운 그룹의 한 구성원에게만 전달됨
- 애니캐스트 통신은 예를 들어 조회에 응답할 수 있는 서버가 여러 개인 경우에 사용됨. 요청은 가장 도달할 수 있는 사람에게 전송

## 멀티 캐스트 주소
- 애니캐스팅과 멀티캐스팅 사이에는 차이가 있음. 애니캐스팅에서는 단 하나 패킷 사본이 그룹 구성원 중 한 명에게 전송됨. 멀티캐스팅에서 각각의 그룹 구성원이 사본을 받음.

># Address Space(주소 공간)
## IPv6의 주소 공간은 2^128개의 주소를 포함합니다. 이 주소 공간은 IPv4 주소의 2^96배이며, 주소가 고갈되지 않습니다. 표시된 바와 같이 공간의 크기는
<img width="457" alt="스크린샷 2024-04-18 오후 1 21 27" src="https://github.com/junhyeok030213/computer_network/assets/106813806/dac21ab2-bd93-4e0e-a4b5-84ed4f46aea3">

># 주소 공간 할당
## IPv4의 주소 공간과 마찬가지로 IPv6의 주소 공간도 다양한 크기의 여러 블록으로 나뉘며 각 블록은 특별한 용도로 할당됩니다. 
## 대부분의 블록은 아직 할당되지 않았으며 향후 사용을 위해 따로 보관되어 있습니다. 
## 표 7.5는 할당된 블록만 보여줍니다. 이 표에서 마지막 열은 전체 주소 공간에서 각 블록이 차지하는 비율을 보여줍니다.

># 표 7.5 할당된 IPv6 주소의 접두사
<img width="632" alt="스크린샷 2024-04-18 오후 1 22 50" src="https://github.com/junhyeok030213/computer_network/assets/106813806/67e8ff50-c8c0-433e-b863-c2cec7e7cfb0">

># 그림 7.41 글로벌 유니캐스트 주소
<img width="704" alt="스크린샷 2024-04-18 오후 1 23 33" src="https://github.com/junhyeok030213/computer_network/assets/106813806/341da31e-25dd-4c20-98aa-e31989517a21">

># 그림 7.42 물리적 주소로 UI-64 매핑
<img width="713" alt="스크린샷 2024-04-18 오후 1 23 59" src="https://github.com/junhyeok030213/computer_network/assets/106813806/aeb0f341-27ed-4430-b55f-aca8a5aaf58e">

># 그림 7.43 이더넷 MAC 매핑
<img width="701" alt="스크린샷 2024-04-18 오후 1 24 23" src="https://github.com/junhyeok030213/computer_network/assets/106813806/8cd37ebf-b8ec-4578-a07e-ae1c1aced643">

># 예 7.26
## 이더넷 주소에 대해 정의한 형식을 사용하여 EUI의 물리적 주소가(F5-A9-23-EF-07-14-7A-D2)_16인 경우 인터페이스 식별자를 찾는다.
# 해결책
## 첫 번째 옥텟의 일곱 일곱 번째 비트만 0에서 1로 변경하면 된다. 형식을 콜론 16진수 표기법으로 변경한다. 결과는 F7A9:23EF:0714:7AD2 이다.

># 예 7.27
## 이더넷 주소에 대해 정의한 형식을 사용하여 이더넷 물리적 주소가 (F5-A9-23-14-7A-D2)_16 인 경우 인터페이스 식별자를 찾는다.
# 해결책
## 첫 번째 옥텟의 일곱 번째 비트를 0에서 1로 변경하고 두 옥텟 FFFE_16 을 삽입한 다음 형식을 콜론 16진수 표기법으로 변경하면 된다. 결과는 콜론 16진수 형식의 F7A9:23FF:FE14:7AD2이다.

># 예 7.28
## 조직에는 블럭 2000:1456:2472/48이 할당된다. 컴퓨터의 IEEE물리적 주소가 다음인 경우 세  번째 서브넷에 있는 인터페이스의 IPv6 주소는 무엇인가?
<img width="248" alt="스크린샷 2024-04-18 오후 1 38 18" src="https://github.com/junhyeok030213/computer_network/assets/106813806/c6f6b6c5-95a0-46ec-87e5-977f5e4f2d51">

# 해결책
## 이 인터페이스의 인터페이스 식별자는 다음과 같다.
<img width="273" alt="스크린샷 2024-04-18 오후 1 52 51" src="https://github.com/junhyeok030213/computer_network/assets/106813806/216ed98a-7853-4018-b114-b55956eb3001">

## 이 식별자를 전역 접두사 및 서브넷 식별자에 할당하면 다음과 같은 결과를 얻는다.
<img width="538" alt="스크린샷 2024-04-18 오후 1 53 02" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d41cc297-b038-4ca0-865a-f5c46b0a8c0e">

># Special Addresses(특별 주소)
## 글로벌 유니캐스트 블록에 대해 논의한 후 표 7.5의 첫 번째 행에 있는 할당된 블록과 예약된 블록의 특성과 목적에 대해 논의합니다. 접두사 (0000:/8)를 사용하는 주소는 예약되지만 이 블록의 일부는 일부 특수한 주소를 정의하는 데 사용됩니다. 그림 7.44는 이 블록의 할당된 주소를 보여줍니다.

># 그림 7.44 특별 주소
<img width="718" alt="스크린샷 2024-04-18 오후 1 41 57" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a12fd19f-4721-4126-aa1e-fba55fbc61e7">

># 기타 할당된 블록
## IPv6는 그림 7.45와 같이 개인 주소 지정을 위한 두 개의 큰 블록과 멀티캐스팅을 위한 하나의 큰 블록을 사용합니다.

># 그림 7.45 고유한 로컬 유니캐스트 블록
<img width="727" alt="스크린샷 2024-04-18 오후 1 43 20" src="https://github.com/junhyeok030213/computer_network/assets/106813806/ee75d85d-b3bb-498f-87fd-02522123e358">

># Autoconfiguration(자동 구성)
## IPv6 주소 지정의 흥미로운 특징 중 하나는 호스트의 자동 구성입니다. 

## IPv4에서 설명했듯이 호스트와 라우터는 원래 네트워크 관리자에 의해 수동으로 구성됩니다. 

## 그러나 동적 호스트 구성 프로토콜인 DHCP를 사용하여 네트워크에 가입하는 호스트에 IPv4 주소를 할당할 수 있습니다. 

## IPv6에서는 DHCP 프로토콜을 사용하여 호스트에 IPv6 주소를 할당할 수 있지만 호스트는 자체적으로 구성할 수도 있습니다.

- 링크 로컬 주소 만들기 -> 고유성 확인 -> 라우터 요청 메시지 전송 및 글로벌 유니캐스트 접두사 결합을 알리는 라우터 알림 메시지 수신

># 예 7.29(1)
## 이더넷 주소(F5-A9-23-11-9B-E2)_16를 가진 호스트가 네트워크에 연결되었다고 가정한다. 조직의 글로벌 유니캐스트 접두사가 3A21:1216:2165이고 서브넷 식별자가 A245:1232인 경우 글로벌 유니캐스트 주소는 무엇인가?
# 해결책
## 호스트는 먼저 인터페이스 식별자를 다음과 같이 생성한다. F7A9:23FF:FE11:9BE2는 카드에서 읽은 이더넷 주소를 사용한다. 그런 다음 호스트는 다음과 같이 링크 로컬 주소를 생성한다. <img width="334" alt="스크린샷 2024-04-18 오후 1 52 12" src="https://github.com/junhyeok030213/computer_network/assets/106813806/2b8f5146-6cca-4c35-af64-dbad59b63c02">


># 예 7.29(2)
## 이 주소가 고유하다고 가정하면 호스트는 라우터 요청 메시지를 보내고 다음과 같이 글로벌 유니캐스트 접두사와 서브넷 식별자의 조합을 알리는 라우터 광고 메시지를 받는다.
<img width="302" alt="스크린샷 2024-04-18 오후 1 51 11" src="https://github.com/junhyeok030213/computer_network/assets/106813806/ba725d97-5960-4129-ada3-1666c6188d59">

## 그런 다음 호스트는 이 접두사에 인터페이스 식별자를 추가하여 글로벌 유니캐스트 주소를 찾아 저장합니다:
<img width="568" alt="스크린샷 2024-04-18 오후 1 51 53" src="https://github.com/junhyeok030213/computer_network/assets/106813806/451650c1-be24-4d64-a0f4-6bf193ee6d73">

># 7.5.2 IPv6 프로토콜
## IPv6 주소 크기를 변경하려면 IPv4 패킷 형식을 변경해야 합니다. 
## IPv6 설계자는 변화가 불가피한 지금 다른 단점에 대한 구제책을 시행하기로 결정했습니다. 
## 다음은 주소 크기 및 형식 변경 외에 프로토콜에 구현된 다른 변경 사항을 보여줍니다.

># IPv6
## IPv4의 결함
- 클래스리스 어드레싱, DHCP 및 NAT을 비롯한 모든 단기 솔루션에도 불구하고 어드레스 고갈은 여전히 장기적인 문제입니다
- 최소 지연 및 리소스 예약이 필요한 실시간 오디오 및 비디오를 수용하는 기능이 없습니다
- 데이터의 암호화 및 인증을 수용하는 기능이 없습니다 
## IPv6(Internetworking Protocol, version 6), AKA IPng(Internetworking Protocol, next generation)이 제안되었습니다.
- 모바일 IP, IP 전화 및 IP 지원 모바일 전화 기술로 IPv6 확산 속도 가속화

># 이점
## 더 큰 주소 공간: 128비트 길이

## 더 나은 헤더 형식: 대부분의 옵션을 라우터에서 확인할 필요가 없기 때문에 라우팅 프로세스를 단순화하고 속도를 높이기 위해 헤더를 기본 헤더로 분리하고 삽입합니다
## 새로운 옵션: 추가 기능
## 연장충당금 : 추가연장이 용이함
## 자원할당을 위한 지원: 실시간 오디오 및 비디오를 위한 패킷의 특별 취급
## 보안 강화를 위한 지원: 패킷의 기밀성과 무결성을 제공하기 위한 암호화 및 인증

># 패킷 형식
## IPv6 패킷은 그림 7.46에 나와 있습니다. 
## 각 패킷은 기본 헤더와 페이로드로 구성됩니다. 
## 기본 헤더는 40바이트를 차지하지만 페이로드는 최대 65,535바이트의 정보를 사용할 수 있습니다. 
## 필드에 대한 설명은 다음과 같습니다.

># 그림 7.46 IPv6 데이터그램
<img width="691" alt="스크린샷 2024-04-18 오후 2 12 24" src="https://github.com/junhyeok030213/computer_network/assets/106813806/b298204b-5791-40b6-84ef-cca4052e591c">

># IPv6 헤더
## 버전: Version 6 : 4 bits
## 트래픽 분류(Traffic Class): 8 bits -> QoS관리: 실시간 서비스 등
## 흐름 표지(label) : 24 bits -> QoS관리: 실시간 서비스 등
- 특수 처리를 요청하는 호스트에서 사용합니다
## 페이로드 길이: 16 bits
- 모든 확장 헤더와 사용자 데이터 포함
## 다음 헤더: 8 bits
- 헤더의 유형을 식별합니다
## 홉 제한(Hop Limit): 8 bits
- IPv4의 TTL 필드 동일
## 발신지 주소: 128 bits
## 목적지 주소: 128 bits

># 그림 7.47 IPv6 데이터그램의 페이로드
<img width="731" alt="스크린샷 2024-04-18 오후 2 30 00" src="https://github.com/junhyeok030213/computer_network/assets/106813806/1d5fab73-82e3-4e71-91bd-4e00c93bc4d9">

># IPv6에서의 플로우 개념과 우선순위
## IP 프로토콜은 원래 connectionless 프로토콜로 설계되었습니다. 그러나 IP 프로토콜을 connection-oriented 프로토콜로 사용하는 경향이 있습니다. 앞에서 설명한 MPLS 기술을 사용하면 라벨 필드를 사용하여 IPv4 패킷을 MPLS 헤더에 캡슐화할 수 있습니다. 
## 버전 6에서는 IPv6 데이터그램의 형식에 플로우 라벨을 직접 추가하여 IPv6를 연결 지향 프로토콜로 사용할 수 있도록 했습니다.

># 조각화 및 재조립
## IPv6 프로토콜에는 아직 데이터그램의 단편화와 재조립이 존재하지만, 이 점에서 큰 차이가 있습니다. 
## IPv6 데이터그램은 라우터가 아닌 소스에 의해서만 단편화될 수 있습니다. 재조립은 대상에서 이루어집니다.
- 송신자는 여러 라우터를 통과하는 패킷의 크기를 확인할 수 있습니다
- 라우터가 앞에 있는 네트워크의 MTU가 허용하는 크기보다 큰 패킷을 드롭하고 패킷이 너무 큰 ICMPv6 오류 메시지를 보냅니다

># 확장 헤더
## IPv6 패킷은 기본 헤더와 일부 확장 헤더로 구성됩니다. 
## 기본 헤더의 길이는 40바이트로 고정되어 있습니다. 그러나 IP 데이터그램에 더 많은 기능을 부여하기 위해 기본 헤더 뒤에는 최대 6개의 확장 헤더가 따를 수 있습니다.
## 이러한 헤더의 대부분은 IPv4의 옵션입니다. 
## 여섯 가지 유형의 확장 헤더가 정의되었습니다. 
## 홉 바이 홉 옵션, 소스 라우팅, 조각화, 인증, 암호화된 보안 페이로드 및 대상 옵션입니다(그림 7.48 참조).

># 그림 7.48 확장 헤더
<img width="720" alt="스크린샷 2024-04-18 오후 2 32 33" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a59e7911-06e8-4f61-9fc3-209cc393b59a">

># 옵션(IPv4 및 IPv6) 비교
## 다음은 IPv4에서 사용되는 옵션과 IPv6에서 사용되는 옵션을 빠르게 비교한 것입니다. 
- 작동하지 않는 옵션과 옵션 종료 옵션은 Pad1과 PadN으로 대체됩니다.
- 레코드 경로 옵션은 IPv6에서 사용되지 않았기 때문에 구현되지 않았습니다.
- 타임스탬프 옵션은 사용되지 않았기 때문에 구현되지 않습니다.
- source route 옵션은 IPv6에서 source route extension 헤더라고 합니다.
- IPv4의 기본 헤더 섹션의 조각화 필드가 IPv6의 조각화 확장 헤더로 이동했습니다
- 인증 확장 헤더는 IPv6에서 새로 추가되었습니다.
- 암호화된 보안 페이로드 확장 헤더는 IPv6에서 새로 추가되었습니다.

># 7.5.3 ICMPv6 프로토콜
## TCP/IP 프로토콜 제품군 버전 6에서 수정된 또 다른 프로토콜은 ICMP입니다. 
## 이 새로운 버전인 ICMPv6는 버전 4의 동일한 전략과 목적을 따릅니다. 그러나 ICMPv6는 ICMPv4보다 더 복잡합니다. 버전 4에서 독립적이었던 일부 프로토콜은 이제 ICMPv6의 일부가 되었고 일부 새로운 메시지는 더 유용하게 추가되었습니다.

># 그림 7.49 버전 4와 버전 6의 네트워크 계층 비교
<img width="723" alt="스크린샷 2024-04-18 오후 2 34 35" src="https://github.com/junhyeok030213/computer_network/assets/106813806/1c523e51-0022-4a4a-89a6-9a31a523e15e">

># 그림 7.50 ICMPv6 메시지의 범주
<img width="724" alt="스크린샷 2024-04-18 오후 2 35 10" src="https://github.com/junhyeok030213/computer_network/assets/106813806/6db477f5-93c5-42ea-9f61-8904291bd251">

## *MLD: Multicast Listener Delivery
## ND: Neighbor-discovery

># 오류 보고 메시지
## 버전 4에 대한 논의에서 살펴보았듯이 ICMPv6의 주요 책임 중 하나는 오류를 보고하는 것입니다. 
## 대상에 도달할 수 없음, 패킷이 너무 큼, 시간 초과됨, 매개 변수 문제 등 네 가지 유형의 오류가 처리됩니다. 
## 버전 4에서 혼잡을 제어하기 위해 사용되는 source-quenched 메시지는 IPv6의 priority 및 flow label 필드가 혼잡을 처리하도록 되어 있기 때문에 이 버전에서는 제거됩니다.

># Neighbor-Discovery Messages(이웃 보고 메시지)
## ICMPv4의 여러 메시지는 인접 검색 문제를 처리하기 위해 ICMPv6에서 재정의되었습니다. 
## 확장 기능을 제공하기 위해 일부 새로운 메시지도 추가되었습니다. 
## 가장 중요한 문제는 이러한 그룹 메시지의 기능을 명확하게 정의하는 두 가지 새로운 프로토콜, 즉 ND(Neighbor-Discovery) 프로토콜과 IND(Inverse-Neighbor-Discovery) 프로토콜의 정의입니다.

># 7.5.3 ICMP6: 이웃 발견 메시지(Neighbor Discovery Message)
## 라우터 요청 메시지(Router-Solicitation Message)
## 라우터 광고 메시지(Router-Advertisement Message)
## 이웃 요청 메시지(Neighbor-Solicitation Message)
## 이웃 광고 메시지(Neighbor-Advertisement Message)
- (ARP) IP 주소 -> 링크 계층 주소
## 재지정 메시지(Redirection Message)
## 역 이웃 요청 메시지(Inverse-Neighbor-Solicitation Message)
## 역 이웃 광고 메시지(Inverse-Neighbor-Advertisement Message
- (RARP) 링크 계층 주소 -> IP 주소

># 그룹 구성원 메시지
## IPv4에서의 멀티캐스트 전달 처리의 관리는 IGMPv3 프로토콜에 주어집니다. 
## IPv6에서 이 책임은 멀티캐스트 청취자 전달 프로토콜에 부여됩니다. 
## MLDv1은 IGMPv2의 대응물이고, MLDv2는 IGMPv3의 대응물입니다. 
## 이 절에서 설명하는 자료는 RFC 3810에서 가져온 것입니다. 이 아이디어는 IGMPv3에서 설명한 것과 동일하지만 IPv6의 더 큰 멀티캐스트 주소 크기에 맞게 메시지의 크기와 형식이 변경되었습니다. MLDv2에는 IGMPv3와 마찬가지로 멤버쉽 쿼리 메시지와 멤버쉽 보고 메시지의 두 가지 유형이 있습니다.

># 7-6 IPv4에서 IPv6으로의 전환
## 비록 새 버전의 IP 프로토콜이 있지만 어떻게 IPv4를 그만 사용하도록 하고 IPv6를 사용하도록 할까? 
## 첫 번째 해답은 모든 호스트나 라우터가 옛 버전을 그만 사용하고 새 버전을 사용하는 변환의 날을 지정하는 것이다. 
## 그러나 인터넷 상의 수많은 시스템이 갑자기 IPv4에서 IPv6로 변경할 수 없기 때문에 이는 실용적이지 못하다. 
## 인터넷 상의 모든 시스템이 IPv4에서 IPv6로 변환하기 위해서는 상당히 많은 시간이 소요될 것이다. 
## IPv4와 IPv6 시스템 사이에 문제가 없도록 프로토콜 버전의 변경은 매끄럽게 진행되어야 한다.
## 23년 1월 기준 IPv6 사용율은 약 39% (세계 평균), 14.33%(한국)
<img width="682" alt="스크린샷 2024-04-18 오후 2 41 16" src="https://github.com/junhyeok030213/computer_network/assets/106813806/a05262f1-f4e2-408d-9303-216d86dd6e03">

># 7.6.1 Strategies
## 전환을 위해 이중 스택, 터널링 및 헤더 변환의 세 가지 전략이 고안되었습니다. 
## 전환 기간 동안 이 세 가지 전략 중 하나 또는 모두를 구현할 수 있습니다.
<img width="611" alt="스크린샷 2024-04-18 오후 2 41 57" src="https://github.com/junhyeok030213/computer_network/assets/106813806/2dcd8df0-551e-4cc2-94db-1a3d5e5aed61">

># Dual Stack(이중 스택)
## 버전 6으로 완전히 마이그레이션하기 전에 전환 중에 모든 호스트에 이중 프로토콜 스택이 있는 것이 좋습니다. 
## 즉, 모든 인터넷이 IPv6를 사용할 때까지 스테이션은 IPv4와 IPv6를 동시에 실행해야 합니다. 
## 이중 스택 구성의 레이아웃은 그림 7.51을 참조하십시오

># 그림 7.51 이중 스택
<img width="714" alt="스크린샷 2024-04-18 오후 2 43 20" src="https://github.com/junhyeok030213/computer_network/assets/106813806/9424f546-bb6c-4b68-8d2b-70286222d556">

># 터널링
## 터널링은 IPv6를 사용하는 두 대의 컴퓨터가 서로 통신하려고 하고 패킷이 IPv4를 사용하는 지역을 통과해야 할 때 사용되는 전략입니다. 
## 이 영역을 통과하기 위해서는 패킷이 IPv4 주소를 가져야 합니다. 따라서 IPv6 패킷은 영역에 들어갈 때 IPv4 패킷에 캡슐화되고 영역을 나갈 때 캡슐화됩니다. 
## 마치 IPv6 패킷이 한쪽 끝에서 터널을 지나 다른 쪽 끝에서 나타나는 것처럼 보입니다. IPv4 패킷이 IPv6 패킷을 데이터로 전송하고 있음을 분명히 하기 위해 프로토콜 값을 41로 설정했습니다. 터널링은 그림 7.52에 나와 있습니다.

># 그림 7.52 터널링 전략
<img width="718" alt="스크린샷 2024-04-18 오후 2 44 11" src="https://github.com/junhyeok030213/computer_network/assets/106813806/1011919b-facf-41e0-a835-b1afc0143fce">

># 헤더 변환
## 헤더 변환은 인터넷의 대부분이 IPv6으로 이동했지만 일부 시스템은 여전히 IPv4를 사용할 때 필요합니다. 
## 송신자는 IPv6를 사용하기를 원하지만 수신자는 IPv6를 이해하지 못합니다. 이 경우 패킷이 IPv4 형식이어야 수신자가 이해할 수 있기 때문에 터널링이 작동하지 않습니다. 
## 이 경우 헤더 변환을 통해 헤더 형식을 완전히 변경해야 합니다. IPv6 패킷의 헤더는 IPv4 헤더로 변환됩니다(그림 7.53 참조).

># 그림 7.53 헤더 번역 전략
<img width="722" alt="스크린샷 2024-04-18 오후 2 45 06" src="https://github.com/junhyeok030213/computer_network/assets/106813806/d350bdfc-4474-4180-a01e-98c40c2b5fd6">
